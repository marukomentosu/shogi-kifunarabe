<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Webå°†æ£‹</title>
    <style>
        :root {
            --board-bg: #f3c77c;
            --line-color: #4e342e;
            --highlight: #fff9c4;
            --valid-move: rgba(100, 255, 100, 0.5);
            --bg-color: #f0f2f5;
            --check-bg: #ffcdd2;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
            background-color: var(--bg-color);
            margin: 0; padding: 10px;
            /* ã‚¹ãƒãƒ›ã§è¦‹åˆ‡ã‚Œã•ã›ãªã„ãŸã‚ã€é«˜ã•ã‚’å›ºå®šã›ãšã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹ */
            min-height: 100vh;
            display: flex; flex-direction: column; align-items: center;
        }

        /* --- ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆå¯¾å±€æƒ…å ±ï¼‰ --- */
        .meta-info {
            display: grid; grid-template-columns: 1.5fr 2fr 1fr 1fr; gap: 5px;
            width: 100%; max-width: 800px; margin-bottom: 10px;
        }
        .meta-input { 
            padding: 6px; border: 1px solid #ccc; border-radius: 4px; width: 100%; font-size: 0.9rem; 
        }
        /* æ—¥ä»˜å…¥åŠ›ã‚¨ãƒªã‚¢ */
        .date-wrapper { display: flex; gap: 2px; }
        .date-btn { 
            padding: 0 8px; background: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 1.2rem;
        }

        /* --- ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --- */
        .main-container {
            display: flex; flex-direction: row; gap: 20px;
            width: 100%; max-width: 1000px; justify-content: center; align-items: flex-start;
        }

        /* ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ */
        .game-area {
            display: flex; flex-direction: column; align-items: center;
            width: auto;
        }

        /* é§’å° */
        .hand {
            display: flex; gap: 2px; padding: 5px; background: #eecfa1; border: 1px solid #8d6e63;
            width: 100%; flex-wrap: wrap; align-items: center; justify-content: center;
            border-radius: 4px; margin: 5px 0; min-height: 45px;
        }
        .hand-label { 
            font-size: 0.8rem; font-weight: bold; margin-right: 8px; 
            background: rgba(255,255,255,0.6); padding: 2px 6px; border-radius: 4px;
            white-space: nowrap;
        }
        .point-badge {
            font-size: 0.75rem; background: #fff; border: 1px solid #aaa; padding: 1px 5px;
            border-radius: 10px; margin-right: 5px; color: #555; font-family: sans-serif;
        }
        .hand-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 4px; }
        .hand-piece { font-size: 1.5rem; cursor: pointer; padding: 0 4px; line-height: 1; user-select: none; position: relative; }
        .hand-piece:hover { background-color: rgba(255,255,255,0.4); border-radius: 4px; }
        .hand-piece.selected { background-color: #fff176; border: 2px solid #fbc02d; border-radius: 4px; }
        .count { font-size: 0.8rem; color: #d32f2f; vertical-align: top; font-weight: bold; }

        /* ç›¤é¢ */
        .board-wrapper {
            position: relative;
            /* PCè¡¨ç¤ºæ™‚ã¯ã‚ã‚‹ç¨‹åº¦ã®å¤§ãã• */
            width: 500px; height: 550px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .board-container {
            width: 100%; height: 100%;
            display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
            border: 2px solid var(--line-color); background-color: var(--board-bg);
            transition: transform 0.4s ease;
        }
        .board-container.flipped { transform: rotate(180deg); }

        .cell {
            border: 0.5px solid var(--line-color); display: flex; justify-content: center; align-items: center;
            font-size: 2.2rem; position: relative; cursor: pointer; user-select: none;
        }
        .cell.selected { background-color: var(--highlight); }
        .cell.checked { background-color: var(--check-bg); }
        .cell.valid::after {
            content: ''; position: absolute; width: 20%; height: 20%;
            background-color: #4caf50; border-radius: 50%; opacity: 0.7;
        }
        .piece { font-weight: bold; line-height: 1; pointer-events: none; white-space: nowrap; font-family: serif; }
        .sente { color: #000; }
        .gote { color: #000; transform: rotate(180deg); }
        .promoted { color: #d50000; }

        .game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.8rem; font-weight: bold; z-index: 10; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; white-space: pre-wrap; text-align: center;
        }
        .game-over-overlay.visible { opacity: 1; pointer-events: auto; }

        /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
        .sidebar {
            width: 280px; display: flex; flex-direction: column; gap: 10px;
            background: #fff; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            /* PCã§ã¯é«˜ã•åˆ¶é™ã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
            max-height: 600px; 
        }
        .turn-indicator {
            text-align: center; font-weight: bold; padding: 8px;
            background: #eee; border-radius: 4px; font-size: 1rem;
        }
        .kifu-list {
            flex: 1; overflow-y: auto; border: 1px solid #ddd;
            font-size: 0.85rem; padding: 5px; background: #fafafa; font-family: monospace; min-height: 150px;
        }
        .kifu-line { padding: 4px; border-bottom: 1px dotted #eee; cursor: pointer; }
        .kifu-line:hover { background-color: #f0f0f0; }
        .kifu-line.current { background-color: #e3f2fd; font-weight: bold; border-left: 4px solid #2196f3; }

        .btn-group { display: flex; gap: 5px; justify-content: space-between; }
        .btn-group.grid { display: grid; grid-template-columns: 1fr 1fr; }
        
        button {
            padding: 10px; font-size: 0.9rem; cursor: pointer; flex: 1;
            background: #fff; border: 1px solid #bbb; border-radius: 4px; touch-action: manipulation;
        }
        button:hover { background: #eee; }
        .btn-save { background-color: #e8f5e9; border-color: #a5d6a7; color: #2e7d32; }
        .btn-resign { background-color: #ffebee; border-color: #ef9a9a; color: #c62828; }
        .btn-draw { background-color: #e3f2fd; border-color: #90caf9; color: #1565c0; }
        
        .playback-controls button { font-family: monospace; font-weight: bold; font-size: 1.1rem; }

        /* --- ã‚¹ãƒãƒ›ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå¯¾å¿œ (ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–) --- */
        @media (max-width: 850px) {
            .meta-info { grid-template-columns: 1fr 1fr; } /* 2åˆ—ã«ã™ã‚‹ */
            
            .main-container {
                flex-direction: column; /* ç¸¦ä¸¦ã³ */
                align-items: center;
                width: 100%;
            }

            .game-area { width: 100%; max-width: 100%; }

            /* ç›¤é¢ã‚’ç”»é¢å¹…ã„ã£ã±ã„ã« */
            .board-wrapper {
                width: 100%;
                max-width: 100%; /* å¹…ã„ã£ã±ã„ */
                height: auto;
                aspect-ratio: 9 / 10; /* æ¯”ç‡ã‚’ç¶­æŒ */
            }
            
            /* ãƒã‚¹ç›®ã®æ–‡å­—ã‚µã‚¤ã‚ºã‚’ç”»é¢å¹…ã«åˆã‚ã›ã¦èª¿æ•´ (vw) */
            .cell { font-size: 9vw; } 

            .hand { width: 100%; max-width: none; }
            .hand-piece { font-size: 2rem; padding: 0 8px; }

            .sidebar {
                width: 100%; max-height: none; /* é«˜ã•ã‚’è‡ªç”±ã« */
                order: 3; /* ä¸€ç•ªä¸‹ã«é…ç½® */
            }
            .kifu-list { max-height: 200px; } /* æ£‹è­œãƒªã‚¹ãƒˆã®é«˜ã•åˆ¶é™ */
        }
    </style>
</head>
<body>

    <div class="meta-info">
        <input type="text" id="meta-event" class="meta-input" placeholder="æ£‹æˆ¦å">
        <div class="date-wrapper">
            <input type="text" id="meta-date-text" class="meta-input" placeholder="æ—¥ä»˜ (ä¾‹:R6/10/1)">
            <button class="date-btn" onclick="document.getElementById('meta-date-picker').showPicker()">ğŸ“…</button>
            <input type="date" id="meta-date-picker" style="visibility:hidden; position:absolute; width:0;" onchange="game.onDatePicked(this.value)">
        </div>
        <input type="text" id="meta-sente" class="meta-input" placeholder="â–²å…ˆæ‰‹" oninput="game.updateHandLabels()">
        <input type="text" id="meta-gote" class="meta-input" placeholder="â–³å¾Œæ‰‹" oninput="game.updateHandLabels()">
    </div>

    <div class="main-container">
        <div class="game-area">
            <div class="hand" id="top-hand-area">
                <span class="hand-label" id="top-hand-label">â–³å¾Œæ‰‹</span>
                <span class="point-badge" id="top-hand-points">0ç‚¹</span>
            </div>

            <div class="board-wrapper">
                <div class="board-container" id="board"></div>
                <div class="game-over-overlay" id="game-over-msg"></div>
            </div>

            <div class="hand" id="bottom-hand-area">
                <span class="hand-label" id="bottom-hand-label">â–²å…ˆæ‰‹</span>
                <span class="point-badge" id="bottom-hand-points">0ç‚¹</span>
            </div>
        </div>

        <div class="sidebar">
            <div class="turn-indicator" id="turn-display">é–‹å§‹å‰</div>
            
            <div class="playback-controls">
                <button onclick="game.goto(0)">|&lt;</button>
                <button onclick="game.prev()">&lt;</button>
                <button onclick="game.next()">&gt;</button>
                <button onclick="game.goto(-1)">&gt;|</button>
            </div>

            <div class="kifu-list" id="kifu-list"></div>

            <div class="btn-group" style="margin-top:5px;">
                <button class="btn-resign" onclick="game.resign()">æŠ•äº†</button>
                <button class="btn-draw" onclick="game.jishogi()">æŒå°†æ£‹</button>
            </div>

            <div class="btn-group grid" style="margin-top:5px;">
                <button onclick="game.rotateBoard()">ç›¤é¢å›è»¢ â†»</button>
                <button class="btn-save" onclick="game.downloadKIF()">KIFä¿å­˜</button>
            </div>
            
            <div class="btn-group grid" style="margin-top:5px;">
                <button onclick="document.getElementById('file-input').click()">èª­è¾¼</button>
                <button class="btn-reset" onclick="if(confirm('åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ')) game.init()">ãƒªã‚»ãƒƒãƒˆ</button>
                <input type="file" id="file-input" accept=".kif,.kifu,.txt" style="display:none" onchange="game.handleFileSelect(event)">
            </div>
        </div>

        <div style="display:none;">
            <div id="hand-sente-container" class="hand-container" onclick="game.onHandClick('sente', event)"></div>
            <div id="hand-gote-container" class="hand-container" onclick="game.onHandClick('gote', event)"></div>
        </div>
    </div>

<script>
    const PIECE_NAMES = { FU:'æ­©', KY:'é¦™', KE:'æ¡‚', GI:'éŠ€', KI:'é‡‘', KA:'è§’', HI:'é£›', OU:'ç‰', TO:'ã¨', NY:'æ', NK:'åœ­', NG:'å…¨', UM:'é¦¬', RY:'é¾' };
    const PIECE_POINTS = { FU:1, KY:1, KE:1, GI:1, KI:1, KA:5, HI:5, OU:0, TO:1, NY:1, NK:1, NG:1, UM:5, RY:5 };
    const NUM_KANJI = ['ã€‡','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','ä¸ƒ','å…«','ä¹'];
    const NUM_ZENKAKU = ['ï¼','ï¼‘','ï¼’','ï¼“','ï¼”','ï¼•','ï¼–','ï¼—','ï¼˜','ï¼™'];
    const MOVES = {
        FU: { step: [[-1, 0]] }, KY: { slide: [[-1, 0]] }, KE: { step: [[-2, -1], [-2, 1]] },
        GI: { step: [[-1, -1], [-1, 0], [-1, 1], [1, -1], [1, 1]] },
        KI: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        OU: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] },
        KA: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }, HI: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        TO: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NY: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NK: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NG: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        UM: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]], step: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        RY: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]], step: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }
    };

    class ShogiGame {
        constructor() {
            this.states = [];
            this.currentStep = 0;
            this.history = [];
            this.viewpoint = 'sente';
            this.selected = null;
            this.validMoves = [];
            
            // åˆæœŸæ—¥ä»˜è¨­å®š
            const today = new Date();
            const y = today.getFullYear();
            const m = String(today.getMonth()+1).padStart(2,'0');
            const d = String(today.getDate()).padStart(2,'0');
            document.getElementById('meta-date-text').value = `${y}/${m}/${d}`;
            
            this.init();
        }

        init() {
            const board = this.createBoard();
            const hands = { sente: {}, gote: {} };
            this.states = [{ 
                board: board, hands: hands, turn: 'sente', 
                lastTo: null, isGameOver: false, msg: "",
                posHash: ""
            }];
            this.states[0].posHash = this.generateHash(this.states[0]);
            
            this.history = [];
            this.currentStep = 0;
            this.viewpoint = 'sente';
            this.updateViewpointDOM();
            this.deselect();
            this.updateView();
            document.getElementById('game-over-msg').classList.remove('visible');
        }

        createBoard() {
            const b = Array(9).fill(null).map(() => Array(9).fill(null));
            const set = (r, c, type, owner) => b[r][c] = { type, owner, promoted: false };
            set(0,0,'KY','gote'); set(0,1,'KE','gote'); set(0,2,'GI','gote'); set(0,3,'KI','gote'); set(0,4,'OU','gote'); set(0,5,'KI','gote'); set(0,6,'GI','gote'); set(0,7,'KE','gote'); set(0,8,'KY','gote');
            set(1,1,'HI','gote'); set(1,7,'KA','gote');
            for(let i=0; i<9; i++) set(2,i,'FU','gote');
            for(let i=0; i<9; i++) set(6,i,'FU','sente');
            set(7,1,'KA','sente'); set(7,7,'HI','sente');
            set(8,0,'KY','sente'); set(8,1,'KE','sente'); set(8,2,'GI','sente'); set(8,3,'KI','sente'); set(8,4,'OU','sente'); set(8,5,'KI','sente'); set(8,6,'GI','sente'); set(8,7,'KE','sente'); set(8,8,'KY','sente');
            return b;
        }

        get currentState() { return this.states[this.currentStep]; }
        get board() { return this.currentState.board; }
        get hands() { return this.currentState.hands; }
        get turn() { return this.currentState.turn; }

        // --- æ—¥ä»˜å‡¦ç† ---
        onDatePicked(val) {
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰é¸æŠã•ã‚ŒãŸ(yyyy-mm-dd)ã‚’ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã«åæ˜ 
            if(val) document.getElementById('meta-date-text').value = val.replace(/-/g, '/');
        }

        formatDateForKIF(input) {
            // å’Œæš¦ãªã©ã‚’è¥¿æš¦(YYYY/MM/DD)ã«å¤‰æ›ã—ã¦è¿”ã™
            let str = input.trim();
            // å…¨è§’æ•°å­—ã‚’åŠè§’ã«
            str = str.replace(/[ï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            
            // å’Œæš¦åˆ¤å®š (ç°¡æ˜“)
            // H30.1.1, R5/10/10, ä»¤å’Œ5å¹´...
            const eraMap = { 'M':1868, 'T':1912, 'S':1926, 'H':1989, 'R':2019, 'æ˜æ²»':1868, 'å¤§æ­£':1912, 'æ˜­å’Œ':1926, 'å¹³æˆ':1989, 'ä»¤å’Œ':2019 };
            
            // "R6..." ãªã©ã‚’æ¤œå‡º
            const warekiRegex = /^([A-Za-z]+|[^\x01-\x7E]+)(\d+)[./å¹´\-](\d+)[./æœˆ\-](\d+)/;
            const match = str.match(warekiRegex);
            if (match) {
                const eraStr = match[1];
                let eraYear = parseInt(match[2]);
                const m = parseInt(match[3]);
                const d = parseInt(match[4]);
                
                // å…ƒå·ã‚ªãƒ•ã‚»ãƒƒãƒˆç‰¹å®š
                let offset = 0;
                for (const [key, val] of Object.entries(eraMap)) {
                    if (eraStr.toUpperCase().startsWith(key) || eraStr === key) {
                        offset = val;
                        // ä»¤å’Œ1å¹´ã¯2019å¹´ã€ä»¤å’Œ2å¹´ã¯2020å¹´... -> (year-1) + offset
                        // æ˜æ²»1å¹´=1868 -> 1868 + 0 
                        // ãƒ­ã‚¸ãƒƒã‚¯çµ±ä¸€: å…ƒå¹´ã¯ offset ã¨å®šç¾©ã—ã¦ã„ã‚‹ã“ã¨ãŒå¤šã„ãŒã€æ­£ç¢ºã«ã¯
                        // ä»¤å’Œ1å¹´ = 2019. (2019 - 1) + 1 = 2019. 
                        // Mapã®å€¤ã¯ã€Œå…ƒå¹´ã€ã®è¥¿æš¦
                        break;
                    }
                }
                if (offset > 0) {
                    const year = offset + eraYear - 1;
                    return `${year}/${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}`;
                }
            }
            
            // è¥¿æš¦æ•´å½¢ (2024-1-1 -> 2024/01/01)
            const seirekiMatch = str.match(/(\d{4})[./\-](\d{1,2})[./\-](\d{1,2})/);
            if (seirekiMatch) {
                return `${seirekiMatch[1]}/${String(seirekiMatch[2]).padStart(2,'0')}/${String(seirekiMatch[3]).padStart(2,'0')}`;
            }

            return str; // å¤‰æ›ä¸èƒ½ãªã‚‰ãã®ã¾ã¾
        }

        // --- è¡¨ç¤ºæ›´æ–° ---
        updateHandLabels() {
            const senteName = document.getElementById('meta-sente').value || "å…ˆæ‰‹";
            const goteName = document.getElementById('meta-gote').value || "å¾Œæ‰‹";
            
            const topLabel = document.getElementById('top-hand-label');
            const topPoints = document.getElementById('top-hand-points');
            const btmLabel = document.getElementById('bottom-hand-label');
            const btmPoints = document.getElementById('bottom-hand-points');

            const senteP = this.calculatePoints('sente');
            const goteP = this.calculatePoints('gote');

            if (this.viewpoint === 'sente') {
                topLabel.innerText = "â–³" + goteName; topPoints.innerText = goteP + "ç‚¹";
                btmLabel.innerText = "â–²" + senteName; btmPoints.innerText = senteP + "ç‚¹";
            } else {
                topLabel.innerText = "â–²" + senteName; topPoints.innerText = senteP + "ç‚¹";
                btmLabel.innerText = "â–³" + goteName; btmPoints.innerText = goteP + "ç‚¹";
            }
        }

        calculatePoints(owner) {
            let p = 0;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const pc = this.board[r][c]; if(pc && pc.owner === owner) p += PIECE_POINTS[pc.type]; } }
            for(const [type, count] of Object.entries(this.hands[owner])) { if(count>0) p += (PIECE_POINTS[type] * count); }
            return p;
        }

        rotateBoard() {
            this.viewpoint = this.viewpoint === 'sente' ? 'gote' : 'sente';
            this.updateViewpointDOM();
        }

        updateViewpointDOM() {
            const boardEl = document.getElementById('board');
            const topArea = document.getElementById('top-hand-area');
            const btmArea = document.getElementById('bottom-hand-area');
            const handSente = document.getElementById('hand-sente-container');
            const handGote = document.getElementById('hand-gote-container');
            if (this.viewpoint === 'gote') {
                boardEl.classList.add('flipped');
                topArea.appendChild(handSente);
                btmArea.appendChild(handGote);
            } else {
                boardEl.classList.remove('flipped');
                topArea.appendChild(handGote);
                btmArea.appendChild(handSente);
            }
            this.updateHandLabels();
        }

        onCellClick(r, c) {
            if (this.currentState.isGameOver) return;
            const move = this.validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                this.performMoveUI(move);
            } else {
                const piece = this.board[r][c];
                if (piece && piece.owner === this.turn) {
                    this.selected = { type: 'board', r, c, piece };
                    this.validMoves = this.getLegalMoves(r, c, piece);
                    this.render();
                } else {
                    this.deselect();
                }
            }
        }

        onHandClick(owner, e) {
            if (this.currentState.isGameOver) return;
            const target = e.target.closest('.hand-piece');
            if (!target || owner !== this.turn) return;
            const type = target.dataset.type;
            if (!this.hands[owner][type]) return;
            this.selected = { type: 'hand', pieceType: type, owner: owner };
            this.validMoves = this.getLegalDropMoves(type, owner);
            this.render();
        }

        deselect() { this.selected = null; this.validMoves = []; this.render(); }

        performMoveUI(move) {
            if (this.currentStep < this.states.length - 1) {
                this.states = this.states.slice(0, this.currentStep + 1);
                this.history = this.history.slice(0, this.currentStep);
            }
            const nextState = JSON.parse(JSON.stringify(this.currentState));
            let moveText = "";
            let promoted = false;
            let fromStr = "";
            const { r: toR, c: toC } = move;

            if (this.selected.type === 'board') {
                const { r: fromR, c: fromC } = this.selected;
                const piece = nextState.board[fromR][fromC];
                const isPromotable = ["FU","KY","KE","GI","KA","HI"].includes(piece.type) && !piece.promoted;
                const inZone = (this.turn === 'sente' && (toR <= 2 || fromR <= 2)) || (this.turn === 'gote' && (toR >= 6 || fromR >= 6));
                if (isPromotable && inZone) { if (confirm("æˆã‚Šã¾ã™ã‹ï¼Ÿ")) promoted = true; }

                const target = nextState.board[toR][toC];
                if (target) {
                    const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                    const rawType = demoteMap[target.type] || target.type;
                    if (!nextState.hands[this.turn][rawType]) nextState.hands[this.turn][rawType] = 0;
                    nextState.hands[this.turn][rawType]++;
                }
                nextState.board[fromR][fromC] = null;
                piece.promoted = piece.promoted || promoted;
                if (promoted) piece.type = this.promoteType(piece.type);
                nextState.board[toR][toC] = piece;
                fromStr = `(${9-fromC}${fromR+1})`;
                moveText = this.generateKifuText(toR, toC, piece.type, promoted, false, fromStr, nextState.lastTo);
            } else {
                const { pieceType } = this.selected;
                nextState.hands[this.turn][pieceType]--;
                nextState.board[toR][toC] = { type: pieceType, owner: this.turn, promoted: false };
                moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
            }
            
            nextState.turn = this.turn === 'sente' ? 'gote' : 'sente';
            nextState.lastTo = { r: toR, c: toC };
            nextState.posHash = this.generateHash(nextState);

            if (this.checkSennichite(nextState)) {
                moveText += " (åƒæ—¥æ‰‹)";
                nextState.isGameOver = true;
                nextState.msg = "åƒæ—¥æ‰‹\nå¼•ãåˆ†ã‘";
            } else if (this.checkMateStatus(nextState)) {
                moveText += " (è©°ã¿)";
                nextState.isGameOver = true;
                const winnerName = this.turn === 'sente' ? (document.getElementById('meta-sente').value||'å…ˆæ‰‹') : (document.getElementById('meta-gote').value||'å¾Œæ‰‹');
                nextState.msg = `${winnerName} å‹\n(è©°ã¿)`;
            }

            this.states.push(nextState);
            this.history.push(moveText);
            this.currentStep++;
            this.deselect();
            this.updateView();
        }

        generateHash(state) { return JSON.stringify({b:state.board, h:state.hands, t:state.turn}); }
        
        checkSennichite(state) {
            const currentHash = state.posHash;
            let count = 0;
            for (const s of this.states) { if (s.posHash === currentHash) count++; }
            return count >= 3; 
        }

        checkMateStatus(state) {
            const turn = state.turn; 
            if (!this.isKingInCheck(state.board, turn)) return false;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const p = state.board[r][c];
                    if (p && p.owner === turn) {
                        const moves = this.getBoardMoves(r, c, p, state.board);
                        for (const m of moves) {
                            if (!this.willBeCheckedInternal(state.board, r, c, m.r, m.c, turn, false)) return false;
                        }
                    }
                }
            }
            for (const type of Object.keys(state.hands[turn])) {
                if (state.hands[turn][type] > 0) {
                    const drops = this.getDropMoves(type, turn, state.board);
                    for (const d of drops) {
                        if (!this.willBeCheckedInternal(state.board, null, null, d.r, d.c, turn, true, type)) return false;
                    }
                }
            }
            return true;
        }

        isKingInCheck(board, owner) {
            let kR = -1, kC = -1;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if(p && p.type === 'OU' && p.owner === owner) { kR = r; kC = c; break; } } }
            if (kR === -1) return false;
            const enemy = owner === 'sente' ? 'gote' : 'sente';
            for(let r=0; r<9; r++){
                for(let c=0; c<9; c++){
                    const p = board[r][c];
                    if (p && p.owner === enemy) {
                        const moves = this.getBoardMoves(r, c, p, board);
                        if (moves.some(m => m.r === kR && m.c === kC)) return true;
                    }
                }
            }
            return false;
        }

        getLegalMoves(r, c, piece) {
            const rawMoves = this.getBoardMoves(r, c, piece, this.board);
            return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, r, c, move.r, move.c, piece.owner, false));
        }
        getLegalDropMoves(type, owner) {
            const rawMoves = this.getDropMoves(type, owner, this.board);
            return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, null, null, move.r, move.c, owner, true, type));
        }
        willBeCheckedInternal(board, fromR, fromC, toR, toC, owner, isDrop, dropType) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            if (isDrop) { tempBoard[toR][toC] = { type: dropType, owner: owner, promoted: false }; } 
            else { const p = tempBoard[fromR][fromC]; tempBoard[fromR][fromC] = null; tempBoard[toR][toC] = p; }
            return this.isKingInCheck(tempBoard, owner);
        }
        getBoardMoves(r, c, piece, currentBoard) {
            const moves = []; const def = MOVES[piece.type]; const flip = piece.owner === 'sente' ? 1 : -1;
            const isValid = (nr, nc) => nr >= 0 && nr < 9 && nc >= 0 && nc < 9;
            const isFriend = (nr, nc) => currentBoard[nr][nc] && currentBoard[nr][nc].owner === piece.owner;
            if (def.step) { def.step.forEach(([dr, dc]) => { const nr = r + (dr * flip), nc = c + (dc * flip); if (isValid(nr, nc) && !isFriend(nr, nc)) moves.push({ r: nr, c: nc }); }); }
            if (def.slide) { def.slide.forEach(([dr, dc]) => { let currR = r, currC = c; while(true) { currR += (dr * flip); currC += (dc * flip); if (!isValid(currR, currC) || isFriend(currR, currC)) break; moves.push({ r: currR, c: currC }); if (currentBoard[currR][currC]) break; } }); }
            return moves;
        }
        getDropMoves(type, owner, currentBoard) {
            const moves = [];
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (currentBoard[r][c]) continue; if (type === 'FU' && this.isNifu(c, owner, currentBoard)) continue; if (this.isStuck(r, type, owner)) continue; moves.push({ r, c }); } }
            return moves;
        }
        promoteType(t) { const m = { FU:'TO', KY:'NY', KE:'NK', GI:'NG', KA:'UM', HI:'RY' }; return m[t] || t; }
        isNifu(c, o, b) { for (let r = 0; r < 9; r++) { const p = b[r][c]; if (p && p.owner === o && p.type === 'FU' && !p.promoted) return true; } return false; }
        isStuck(r, t, o) { if (o === 'sente') { if ((t === 'FU' || t === 'KY') && r === 0) return true; if (t === 'KE' && r <= 1) return true; } else { if ((t === 'FU' || t === 'KY') && r === 8) return true; if (t === 'KE' && r >= 7) return true; } return false; }
        
        prev() { if(this.currentStep > 0) { this.currentStep--; this.updateView(); } }
        next() { if(this.currentStep < this.states.length - 1) { this.currentStep++; this.updateView(); } }
        goto(step) { if (step === -1) step = this.states.length - 1; this.currentStep = Math.max(0, Math.min(step, this.states.length - 1)); this.updateView(); }
        
        resign() { 
            if (this.currentState.isGameOver) return; 
            if (!confirm("æŠ•äº†ã—ã¾ã™ã‹ï¼Ÿ")) return; 
            const state = JSON.parse(JSON.stringify(this.currentState)); 
            state.isGameOver = true; 
            state.msg = `${this.turn === 'sente' ? (document.getElementById('meta-sente').value||'â–²å…ˆæ‰‹') : (document.getElementById('meta-gote').value||'â–³å¾Œæ‰‹')} æŠ•äº†`; 
            this.states.push(state); this.history.push("æŠ•äº†"); this.currentStep++; this.updateView(); 
        }
        
        jishogi() {
            if (this.currentState.isGameOver) return;
            if (!confirm("æŒå°†æ£‹ï¼ˆå¼•ãåˆ†ã‘ï¼‰ã«ã—ã¾ã™ã‹ï¼Ÿ")) return;
            const state = JSON.parse(JSON.stringify(this.currentState));
            state.isGameOver = true;
            state.msg = "æŒå°†æ£‹\nå¼•ãåˆ†ã‘";
            this.states.push(state); this.history.push("æŒå°†æ£‹"); this.currentStep++; this.updateView();
        }

        updateView() { this.render(); this.renderKifuList(); this.updateStatus(); this.updateHandLabels(); const overlay = document.getElementById('game-over-msg'); if (this.currentState.isGameOver) { overlay.innerText = this.currentState.msg; overlay.classList.add('visible'); } else { overlay.classList.remove('visible'); } }
        
        render() {
            const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
            let checkedPos = null;
            if (this.isKingInCheck(this.board, this.turn)) {
                for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = this.board[r][c]; if(p && p.type === 'OU' && p.owner === this.turn) { checkedPos = {r,c}; break; } } }
            }
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const cell = document.createElement('div'); cell.className = 'cell'; if (this.selected && this.selected.type === 'board' && this.selected.r === r && this.selected.c === c) cell.classList.add('selected'); if (this.validMoves.some(m => m.r === r && m.c === c)) cell.classList.add('valid'); 
            if (checkedPos && checkedPos.r === r && checkedPos.c === c) cell.classList.add('checked');
            cell.onclick = () => this.onCellClick(r, c); const p = this.board[r][c]; if (p) { const span = document.createElement('span'); span.className = `piece ${p.owner} ${p.promoted ? 'promoted' : ''}`; span.innerText = PIECE_NAMES[p.type]; cell.appendChild(span); } boardEl.appendChild(cell); } }
            this.renderHand('sente'); this.renderHand('gote');
        }
        renderHand(owner) { const container = document.getElementById(`hand-${owner}-container`); container.innerHTML = ''; for (const [type, count] of Object.entries(this.hands[owner])) { if (count > 0) { const div = document.createElement('div'); div.className = 'hand-piece'; div.dataset.type = type; div.innerHTML = `${PIECE_NAMES[type]}<span class="count">${count>1?count:''}</span>`; if (this.selected && this.selected.type === 'hand' && this.selected.owner === owner && this.selected.pieceType === type) div.classList.add('selected'); container.appendChild(div); } } }
        renderKifuList() { const list = document.getElementById('kifu-list'); list.innerHTML = this.history.map((line, i) => `<div class="kifu-line ${i === this.currentStep - 1 ? 'current' : ''}" onclick="game.goto(${i+1})">${i+1}: ${line}</div>`).join(''); const currentEl = list.querySelector('.current'); if (currentEl) currentEl.scrollIntoView({ block: "center", behavior: "smooth" }); }
        updateStatus() { const el = document.getElementById('turn-display'); if (this.currentState.isGameOver) { el.innerText = "çµ‚å±€"; el.style.borderBottom = "3px solid #555"; } else { const sName = document.getElementById('meta-sente').value || "å…ˆæ‰‹"; const gName = document.getElementById('meta-gote').value || "å¾Œæ‰‹"; el.innerText = `${this.turn === 'sente' ? 'â–²'+sName : 'â–³'+gName} (${this.currentStep}æ‰‹)`; el.style.borderBottom = `3px solid ${this.turn === 'sente' ? '#000' : '#d32f2f'}`; } }
        generateKifuText(r, c, type, promoted, isDrop, fromStr, lastTo) { const x = 9 - c; const y = NUM_KANJI[r + 1]; const xStr = NUM_ZENKAKU[x]; let dest = `${xStr}${y}`; if (lastTo && lastTo.r === r && lastTo.c === c) dest = "åŒã€€"; let pName = PIECE_NAMES[type]; if (promoted) pName = (type === 'FU' ? 'ã¨' : (type === 'KA' ? 'é¦¬' : (type === 'HI' ? 'é¾' : pName + 'æˆ'))); if (promoted && !pName.endsWith('æˆ') && !['ã¨','é¦¬','é¾'].includes(pName)) pName += 'æˆ'; return `${dest}${pName}${isDrop ? 'æ‰“' : ''}${fromStr}`; }
        
        createKIFString() { 
            const dRaw = document.getElementById('meta-date-text').value;
            const dFmt = this.formatDateForKIF(dRaw);
            let kif = `# KIF formated by WebShogi\n`; 
            kif += `é–‹å§‹æ—¥æ™‚ï¼š${dFmt}\n`; 
            kif += `æ£‹æˆ¦ï¼š${document.getElementById('meta-event').value}\n`; 
            kif += `å…ˆæ‰‹ï¼š${document.getElementById('meta-sente').value}\n`; 
            kif += `å¾Œæ‰‹ï¼š${document.getElementById('meta-gote').value}\n`; 
            kif += `æ‰‹æ•°----æŒ‡æ‰‹---------æ¶ˆè´¹æ™‚é–“--\n`; 
            this.history.forEach((line, i) => kif += `${String(i + 1).padStart(4, ' ')} ${line}\n`); 
            return kif; 
        }
        
        downloadKIF() { 
            const blob = new Blob([this.createKIFString()], { type: 'text/plain' }); 
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(blob); 
            // ãƒ•ã‚¡ã‚¤ãƒ«åç”¨æ—¥ä»˜
            const d = this.formatDateForKIF(document.getElementById('meta-date-text').value).replace(/\//g, '');
            a.download = `shogi_${d||'game'}.kif`; 
            a.click(); 
        }
        
        handleFileSelect(evt) {
            const file = evt.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            // æ–‡å­—ã‚³ãƒ¼ãƒ‰è‡ªå‹•åˆ¤å®šï¼ˆShift_JISã‹UTF-8ã‹ï¼‰
            reader.onload = (e) => {
                const buffer = e.target.result;
                let decoder = new TextDecoder('shift-jis');
                let text = decoder.decode(buffer);
                // Shift_JISã§ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦ã€æ˜ã‚‰ã‹ã«æ–‡å­—åŒ–ã‘ã—ã¦ã„ã‚‹ï¼ˆå°†æ£‹ç”¨èªãŒå«ã¾ã‚Œãªã„ï¼‰å ´åˆã€UTF-8ã§å†è©¦è¡Œ
                if (!text.includes('æ‰‹æ•°') && !text.includes('å…ˆæ‰‹') && !text.includes('1 ')) {
                    decoder = new TextDecoder('utf-8');
                    text = decoder.decode(buffer);
                }
                this.importKIF(text);
            };
            reader.readAsArrayBuffer(file);
        }

        importKIF(text) {
            if(!confirm("ç¾åœ¨ã®ç›¤é¢ã‚’ç ´æ£„ã—ã¦èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ")) return;
            this.init();
            const lines = text.split(/\r\n|\n/);
            const moveRegex = /^\s*[0-9]+\s+([ï¼‘-ï¼™1-9åŒ])\s?([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹1-9ã€€])\s?(.*)/; 
            
            lines.forEach(line => {
                if(line.includes("æ£‹æˆ¦ï¼š")) document.getElementById('meta-event').value = line.split("ï¼š")[1].trim();
                if(line.includes("å…ˆæ‰‹ï¼š")) document.getElementById('meta-sente').value = line.split("ï¼š")[1].trim();
                if(line.includes("å¾Œæ‰‹ï¼š")) document.getElementById('meta-gote').value = line.split("ï¼š")[1].trim();
                
                // é–‹å§‹æ—¥æ™‚ãƒ‘ãƒ¼ã‚¹
                const dateMatch = line.match(/é–‹å§‹æ—¥æ™‚[ï¼š:]\s*(.+)/);
                if (dateMatch) {
                    // YYYY/MM/DD å½¢å¼ãªã‚‰ãã®ã¾ã¾ã€ãã†ã§ãªã‘ã‚Œã°æŠ½å‡º
                    const dateStr = dateMatch[1].trim();
                    const stdDate = dateStr.match(/(\d{4})[./-](\d{1,2})[./-](\d{1,2})/);
                    if (stdDate) {
                        document.getElementById('meta-date-text').value = `${stdDate[1]}/${String(stdDate[2]).padStart(2,'0')}/${String(stdDate[3]).padStart(2,'0')}`;
                    } else {
                        document.getElementById('meta-date-text').value = dateStr;
                    }
                }
            });
            this.updateHandLabels();

            for (let line of lines) {
                const match = line.match(moveRegex);
                if (match) {
                    let toXStr = match[1]; let toYStr = match[2]; let rest = match[3].trim();
                    let toC, toR;
                    if (toXStr === 'åŒ') {
                        const lastTo = this.currentState.lastTo; if (!lastTo) continue;
                        toR = lastTo.r; toC = lastTo.c;
                    } else {
                        const x = this.toNum(toXStr); const y = this.kanjiToNum(toYStr);
                        toC = 9 - x; toR = y - 1;
                    }
                    const fromMatch = rest.match(/\((\d)(\d)\)/);
                    const isDrop = rest.includes('æ‰“');
                    const isPromote = rest.includes('æˆ') && !rest.includes('æˆéŠ€') && !rest.includes('æˆæ¡‚') && !rest.includes('æˆé¦™');
                    let pieceType = 'FU';
                    for (const [key, val] of Object.entries(PIECE_NAMES)) { if (rest.startsWith(val)) { pieceType = key; break; } }
                    if (rest.includes('æˆéŠ€')) pieceType = 'GI'; if (rest.includes('ã¨')) pieceType = 'FU'; 

                    const nextState = JSON.parse(JSON.stringify(this.currentState));
                    const turn = nextState.turn;
                    let moveText = "";

                    if (isDrop) {
                         nextState.hands[turn][pieceType]--;
                         nextState.board[toR][toC] = { type: pieceType, owner: turn, promoted: false };
                         moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
                    } else {
                        let fromR, fromC;
                        if (fromMatch) { const fx = parseInt(fromMatch[1]); const fy = parseInt(fromMatch[2]); fromC = 9 - fx; fromR = fy - 1; } 
                        else { continue; }
                        const piece = nextState.board[fromR][fromC];
                        const target = nextState.board[toR][toC];
                        if (target) {
                            const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                            const rawType = demoteMap[target.type] || target.type;
                            if (!nextState.hands[turn][rawType]) nextState.hands[turn][rawType] = 0;
                            nextState.hands[turn][rawType]++;
                        }
                        nextState.board[fromR][fromC] = null;
                        piece.promoted = piece.promoted || isPromote;
                        if (isPromote) piece.type = this.promoteType(piece.type);
                        nextState.board[toR][toC] = piece;
                        moveText = line.split('(')[0].trim() + `(${9-fromC}${fromR+1})`;
                    }
                    nextState.turn = turn === 'sente' ? 'gote' : 'sente';
                    nextState.lastTo = { r: toR, c: toC };
                    nextState.posHash = this.generateHash(nextState);

                    if (this.checkSennichite(nextState)) {
                        moveText += " (åƒæ—¥æ‰‹)";
                        nextState.isGameOver = true;
                        nextState.msg = "åƒæ—¥æ‰‹\nå¼•ãåˆ†ã‘";
                    } else if (this.checkMateStatus(nextState)) {
                        moveText += " (è©°ã¿)";
                        nextState.isGameOver = true;
                        const winner = turn === 'sente' ? document.getElementById('meta-sente').value : document.getElementById('meta-gote').value;
                        nextState.msg = `${winner||(turn==='sente'?'å…ˆæ‰‹':'å¾Œæ‰‹')} å‹\n(è©°ã¿)`;
                    } else if (line.includes("æŠ•äº†")) {
                        nextState.isGameOver = true;
                        nextState.msg = line.split(/\s+/)[1] + " æŠ•äº†";
                    } else if (line.includes("æŒå°†æ£‹") || line.includes("åƒæ—¥æ‰‹")) {
                        nextState.isGameOver = true;
                        nextState.msg = "å¼•ãåˆ†ã‘";
                    } else if (line.includes("åå‰‡")) {
                        nextState.isGameOver = true;
                        nextState.msg = "åå‰‡æ±ºç€";
                    }

                    this.states.push(nextState);
                    this.history.push(moveText);
                    this.currentStep++;
                }
            }
            this.updateView();
            alert("èª­ã¿è¾¼ã¿å®Œäº†");
        }
        toNum(str) { const zen = "ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"; const idx = zen.indexOf(str); return idx >= 0 ? idx + 1 : parseInt(str); }
        kanjiToNum(str) { const k = "ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹"; const idx = k.indexOf(str); return idx >= 0 ? idx + 1 : this.toNum(str); }
    }

    const game = new ShogiGame();
</script>
</body>
</html>
