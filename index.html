<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HTML将棋 Ultra - KIF Compatibility Edition</title>
    <style>
        :root {
            --bg-deep: #121212; --bg-panel: #1e1e1e; --board-dark: #3a2a1d;
            --cell-border: #554433; --text-main: #e0e0e0; --text-accent: #ffcc00;
            --selected-bg: rgba(255, 204, 0, 0.4); --btn-bg: #333333;
            --btn-border: #444444; --cell-size: min(10.5vw, 5.8vh, 50px);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body { font-family: 'Hiragino Mincho ProN', serif; display: flex; flex-direction: column; height: 100dvh; margin: 0; background: var(--bg-deep); color: var(--text-main); overflow: hidden; padding: 4px; }
        .game-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; min-height: 0; }
        .game-container.rotated { flex-direction: column-reverse; }
        .komadai { width: 98%; max-width: 500px; height: 50px; background: var(--bg-panel); border: 1px solid var(--btn-border); display: flex; align-items: center; padding: 0 10px; border-radius: 8px; }
        .player-name { font-size: 13px; font-weight: bold; margin-right: 8px; color: var(--text-accent); }
        .hand-container { display: flex; gap: 6px; flex: 1; overflow-x: auto; align-items: center; }
        .hand-piece { font-size: 22px; cursor: pointer; color: #fdf5e6; transition: transform 0.2s; display: inline-block; }
        .p-flip { transform: rotate(180deg); }
        .hand-piece.selected { background: var(--selected-bg); box-shadow: 0 0 12px var(--text-accent); transform: scale(1.25); }
        .board-wrapper { display: flex; flex-direction: column; align-items: center; }
        .status-msg { height: 20px; color: var(--text-accent); font-weight: bold; font-size: 14px; margin-bottom: 2px; }
        .board { display: grid; grid-template-columns: repeat(9, var(--cell-size)); background: var(--board-dark); border: 2px solid #000; }
        .board.rotated { transform: rotate(180deg); }
        .cell { width: var(--cell-size); height: var(--cell-size); border: 0.5px solid var(--cell-border); display: flex; align-items: center; justify-content: center; font-size: calc(var(--cell-size) * 0.7); cursor: pointer; color: #fdf5e6; position: relative; }
        .cell.selected { background: var(--selected-bg); }
        .cell.last-move { background: rgba(255, 100, 0, 0.2); }
        .legal-dot { width: 12px; height: 12px; background: rgba(0, 255, 150, 0.4); border-radius: 50%; position: absolute; pointer-events: none; }
        #kifu-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 200; flex-direction: column; padding: 15px; }
        #kifu-list { flex: 1; overflow-y: auto; background: #000; border-radius: 8px; padding: 8px; display: flex; flex-wrap: wrap; gap: 5px; }
        .kifu-line { cursor: pointer; padding: 6px 10px; background: #222; border-radius: 4px; color: #aaa; font-size: 13px; }
        .kifu-line.active { background: var(--text-accent); color: #000; }
        .controls { width: 100%; max-width: 500px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 4px; }
        button { padding: 10px 2px; cursor: pointer; background: var(--btn-bg); border: 1px solid var(--btn-border); border-radius: 6px; color: var(--text-main); font-weight: bold; font-size: 11px; }
        #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 300; align-items: center; justify-content: center; }
        .modal-content { background: var(--bg-panel); padding: 15px; border-radius: 12px; width: 90%; max-width: 380px; display: flex; flex-direction: column; gap: 10px; }
        .modal-content input { background: #000; border: 1px solid var(--btn-border); padding: 12px; color: var(--text-main); border-radius: 6px; width: 100%; }
    </style>
</head>
<body>

<div id="kifu-overlay" onclick="toggleKifu(false)">
    <h3 style="color:var(--text-accent); margin:0 0 10px 0;">棋譜履歴</h3>
    <div id="kifu-list" onclick="event.stopPropagation()"></div>
    <button onclick="toggleKifu(false)" style="margin-top:10px; width:100%;">閉じる</button>
</div>

<div id="modal-overlay">
    <div class="modal-content" onclick="event.stopPropagation()">
        <h3 id="modal-title" style="margin:0; color:var(--text-accent);">対局設定</h3>
        <div><label style="font-size:11px;">棋戦名</label><input type="text" id="event" placeholder="棋戦名"></div>
        <div><label style="font-size:11px;">対局日 (西暦表記に自動変換されます)</label><input type="text" id="date-text"></div>
        <div style="display:flex; gap:5px;"><input type="text" id="sente-input" placeholder="先手" style="flex:1"><input type="text" id="gote-input" placeholder="後手" style="flex:1"></div>
        <div id="filename-area" style="display:none;"><label style="font-size:11px;">ファイル名</label><input type="text" id="filename-input"></div>
        <div style="display:flex; gap:8px;"><button onclick="closeSettings()" style="flex:1">キャンセル</button><button id="save-final-btn" style="flex:1; background:#114422; color:#66ff99; display:none;" onclick="executeDownload()">保存</button></div>
    </div>
</div>

<div class="game-container" id="main-container">
    <div class="komadai" id="hand-gote"><div class="player-name" id="name-display-gote">後手</div><div class="hand-container"></div></div>
    <div class="board-wrapper"><div class="status-msg" id="msg">先手番</div><div id="board" class="board"></div></div>
    <div class="komadai" id="hand-sente"><div class="player-name" id="name-display-sente">先手</div><div class="hand-container"></div></div>
</div>

<div class="controls">
    <button onclick="jumpTo(0)">|◀</button><button onclick="prevMove()" style="grid-column: span 1.5">◀ 前へ</button><button onclick="nextMove()" style="grid-column: span 1.5">次へ ▶</button><button onclick="jumpTo(history.length - 1)">▶|</button>
    <button style="color:var(--text-accent)" onclick="undoMove()">一手戻す</button><button onclick="toggleRotate()">盤反転</button><button onclick="toggleKifu(true)">棋譜</button><button style="color:#99ccff" onclick="resetGame()">最初から</button>
    <button style="grid-column: span 2;" onclick="openSettings('info')">対局設定</button>
    <input type="file" id="kifu-import-input" style="display:none" accept=".kif" onchange="importKifu(event)">
    <button style="grid-column: span 2; background:#444400;" onclick="document.getElementById('kifu-import-input').click()">プロ棋譜を取込</button>
    <button style="grid-column: span 2; color:#ff6666" onclick="resignGame()">投了</button>
    <button style="grid-column: span 2; background:#114422; color:#66ff99;" onclick="openSettings('save')">プロ形式で保存 (.kif)</button>
</div>

<script>
    const P_MOVE = {
        '歩': { m: [[-1, 0]], up: 'と' }, '香': { m: [[-10, 0]], up: '杏' }, '桂': { m: [[-2, -1], [-2, 1]], up: '圭' },
        '銀': { m: [[-1, 0], [-1, -1], [-1, 1], [1, -1], [1, 1]], up: '全' }, '金': { m: [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0]], up: null },
        '角': { m: [[-10, -10], [-10, 10], [10, -10], [10, 10]], up: '馬' }, '飛': { m: [[-10, 0], [10, 0], [0, -10], [0, 10]], up: '龍' },
        '玉': { m: [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]], up: null }, '王': { m: [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]], up: null },
        'と': { m: [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0]], up: null }, '杏': { m: [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0]], up: null },
        '圭': { m: [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0]], up: null }, '全': { m: [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0]], up: null },
        '馬': { m: [[-10, -10], [-10, 10], [10, -10], [10, 10], [-1, 0], [1, 0], [0, -1], [0, 1]], up: null }, '龍': { m: [[-10, 0], [10, 0], [0, -10], [0, 10], [-1, -1], [-1, 1], [1, -1], [1, 1]], up: null }
    };

    let board, hands, turn, selected, history, currentIndex, result, isRotated = false;

    function parseDate(dateStr) {
        if (!dateStr) return "";
        let s = dateStr.trim();
        const eras = { 'R': 2018, 'H': 1988, 'S': 1925, 'T': 1911, 'M': 1867, '令和': 2018, '平成': 1988, '昭和': 1925, '大正': 1911, '明治': 1867 };
        const match = s.match(/^([MTSHR]|明治|大正|昭和|平成|令和)(\d+|元)(.*)/i);
        if (match) {
            const baseYear = eras[match[1].toUpperCase()];
            const yearNum = match[2] === '元' ? 1 : parseInt(match[2]);
            const rest = match[3].replace(/[年月日]/g, '/').replace(/\/$/, '');
            return (baseYear + yearNum) + rest;
        }
        return s;
    }

    function init() {
        board = Array(9).fill().map(() => Array(9).fill(null));
        hands = { sente: { '歩':0,'香':0,'桂':0,'銀':0,'金':0,'角':0,'飛':0 }, gote: { '歩':0,'香':0,'桂':0,'銀':0,'金':0,'角':0,'飛':0 } };
        const l1 = ['香','桂','銀','金','玉','金','銀','桂','香'];
        l1.forEach((p, c) => board[0][c] = {p, owner:'gote'});
        board[1][1] = {p:'飛', owner:'gote'}; board[1][7] = {p:'角', owner:'gote'};
        for(let i=0; i<9; i++) board[2][i] = {p:'歩', owner:'gote'};
        for(let i=0; i<9; i++) board[6][i] = {p:'歩', owner:'sente'};
        board[7][1] = {p:'角', owner:'sente'}; board[7][7] = {p:'飛', owner:'sente'};
        l1.forEach((p, c) => board[8][c] = {p: p==='玉'?'玉':p, owner:'sente'});
        turn = 'sente'; selected = null; history = []; result = null;
        const n = new Date(); document.getElementById('date-text').value = `${n.getFullYear()}/${(n.getMonth()+1).toString().padStart(2,'0')}/${n.getDate().toString().padStart(2,'0')}`;
        saveHistory(null, null, null, null, "開始"); render();
    }

    function importKifu(e) {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const lines = event.target.result.split('\n');
            init();
            lines.forEach(line => {
                const l = line.trim();
                if (l.startsWith('先手：')) document.getElementById('sente-input').value = l.split(/[：:]/)[1].trim();
                if (l.startsWith('後手：')) document.getElementById('gote-input').value = l.split(/[：:]/)[1].trim();
                if (l.startsWith('棋戦：')) document.getElementById('event').value = l.split(/[：:]/)[1].trim();
                if (l.startsWith('開始日時：') || l.startsWith('対局日：')) {
                    const rawDate = l.split(/[：:]/)[1].trim();
                    document.getElementById('date-text').value = parseDate(rawDate);
                }
            });
            syncDisplayNames();
            for (let line of lines) {
                const l = line.trim();
                const match = l.match(/^\d+\s+([１-９同][一二三四五六七八九　]+)([^(\s]+)(?:\((\d)(\d)\))?/);
                if (!match) { if (l.includes('投了')) applyResignResult(); continue; }
                let tr, tc; const posStr = match[1], pieceSuffix = match[2], srcX = match[3], srcY = match[4];
                if (posStr.includes('同')) { const last = history[history.length-1].lastPos; tr = last.r; tc = last.c; }
                else { tc = "９８７６５４３２１".indexOf(posStr[0]); tr = "一二三四五六七八九".indexOf(posStr[1]); }
                const basePiece = pieceSuffix[0];
                if (pieceSuffix.includes('打')) executeMove(null, null, tr, tc, basePiece, true, true);
                else if (srcX && srcY) { const fr = parseInt(srcY)-1, fc = 9-parseInt(srcX); executeMove(fr, fc, tr, tc, board[fr][fc].p, false, true); }
                else {
                    let found = false;
                    for (let r=0; r<9; r++) for (let c=0; c<9; c++) {
                        const p = board[r][c];
                        if (p && p.owner === turn && canMove(board, r, c, tr, tc, turn) && (p.p===basePiece || P_MOVE[p.p].up===basePiece)) {
                            executeMove(r, c, tr, tc, p.p, false, true); found = true; break;
                        }
                    }
                }
            }
            render();
            alert(`棋譜を読み込みました。`);
        };
        reader.readAsText(file, "Shift_JIS");
    }

    /* --- 保存機能：Kifu for iOS 公式形式に完全準拠 --- */
    function executeDownload() {
        const sente = document.getElementById('sente-input').value || "先手";
        const gote = document.getElementById('gote-input').value || "後手";
        const event = document.getElementById('event').value || "対局";
        const date = document.getElementById('date-text').value;

        // 公式ファイルと同じ改行コード (LF) を使用
        const NL = "\n";
        
        // ヘッダー：公式ファイル (V4.73) の構成を再現
        let out = `#KIF version=2.0 encoding=UTF-8${NL}`;
        out += `# ---- Kifu for iPhone V4.73 棋譜ファイル ----${NL}`; 
        out += `開始日時：${date}${NL}`;
        out += `終了日時：${date}${NL}`;
        out += `棋戦：${event}${NL}`;
        out += `場所：${NL}`;
        out += `手合割：平手${NL}`;
        out += `先手：${sente}${NL}`;
        out += `後手：${gote}${NL}`;
        out += `手数----指手---------消費時間--${NL}`;

        history.slice(1).forEach((h, i) => {
            // 手数：4文字幅で右詰め
            const num = (i + 1).toString().padStart(4, ' ');
            
            // 指し手と時間の余白：公式の通りカッコの開始位置を揃える
            // 7文字(標準的な指し手) + 3スペース = 10文字目付近から開始するように調整
            const move = h.moveStr.padEnd(10, ' ');
            out += `${num} ${move}   ( 0:00/00:)${NL}`;
        });

        // 投了時の結果出力
        if (result) {
            const lastNum = history.length.toString().padStart(4, ' ');
            out += `${lastNum} 投了            ( 0:00/00:)${NL}`;
        }

        // UTF-8(BOM付き)で作成 (ブラウザからのダウンロードで文字化けを防ぐため)
        const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
        const blob = new Blob([bom, out], { type: 'text/plain;charset=utf-8' });
        
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const safeName = (document.getElementById('filename-input').value || "shogi").replace(/[\\/:*?"<>|]/g, "");
        a.download = `${safeName}.kif`;
        a.click();
        closeSettings();
    }

    function executeMove(fr, fc, tr, tc, piece, isDrop = false, skipPromoteConfirm = false) {
        let finalPiece = piece, suffix = "";
        const last = history[currentIndex].lastPos;
        const isSamePos = last && last.r === tr && last.c === tc;
        const posStr = isSamePos ? "同　" : "９８７６５４３２１"[tc] + "一二三四五六七八九"[tr];
        if (isDrop) { hands[turn][piece]--; suffix = "打"; }
        else {
            if (board[tr][tc]) { const cap = board[tr][tc].p, rev = {'と':'歩','杏':'香','圭':'桂','全':'銀','馬':'角','龍':'飛'}; hands[turn][rev[cap] || cap]++; }
            if (P_MOVE[piece].up && ((turn === 'sente' && (fr <= 2 || tr <= 2)) || (turn === 'gote' && (fr >= 6 || tr >= 6)))) { 
                if (skipPromoteConfirm || confirm("成りますか？")) { finalPiece = P_MOVE[piece].up; suffix = "成"; } else suffix = "不成"; 
            }
            board[fr][fc] = null;
        }
        board[tr][tc] = { p: finalPiece, owner: turn };
        let moveStr = `${posStr}${finalPiece}${suffix}`;
        if (!isDrop) moveStr += `(${9-fc}${fr+1})`;
        saveHistory(tr, tc, fr, fc, moveStr); turn = (turn === 'sente' ? 'gote' : 'sente'); render();
    }
    function saveHistory(tr, tc, fr, fc, moveStr) { history.push({ board: JSON.parse(JSON.stringify(board)), hands: JSON.parse(JSON.stringify(hands)), lastPos: {r: tr, c: tc}, moveStr, turn }); currentIndex = history.length - 1; updateKifuList(); }
    function canMove(b, fr, fc, tr, tc, owner) { const pData = b[fr][fc]; if (!pData) return false; const dest = b[tr][tc]; if (dest && dest.owner === owner) return false; const moves = P_MOVE[pData.p].m, mult = owner === 'sente' ? 1 : -1; for (let [mr, mc] of moves) { const trgR = mr * mult, trgC = mc * mult; if (Math.abs(mr) < 10 && Math.abs(mc) < 10) { if (tr-fr === trgR && tc-fc === trgC) return true; } else { const sR = Math.sign(trgR), sC = Math.sign(trgC); for (let i=1; i<9; i++) { const cR=fr+sR*i, cC=fc+sC*i; if (cR<0||cR>8||cC<0||cC>8) break; if (cR===tr && cC===tc) return true; if (b[cR][cC]) break; } } } return false; }
    function render() {
        const state = history[currentIndex]; const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
        const lastP = (currentIndex > 0) ? state.lastPos : null; const legalMoves = getLegalMoves();
        for (let r=0; r<9; r++) for (let c=0; c<9; c++) {
            const cell = document.createElement('div'); cell.className = `cell ${selected?.type==='board'&&selected.r===r&&selected.c===c?'selected':''} ${lastP?.r===r&&lastP.c===c?'last-move':''}`;
            const d = state.board[r][c]; if (d) { const s = document.createElement('span'); s.textContent = d.p; if (d.owner === 'gote') s.className = 'p-flip'; cell.appendChild(s); }
            if (legalMoves.some(m => m.r === r && m.c === c)) { const dot = document.createElement('div'); dot.className = 'legal-dot'; cell.appendChild(dot); }
            if (!result && currentIndex === history.length - 1) cell.onclick = () => handleCellClick(r, c);
            boardEl.appendChild(cell);
        }
        updateHandUI('sente', state.hands.sente); updateHandUI('gote', state.hands.gote); updateStatus();
    }
    function handleCellClick(r, c) { const clicked = board[r][c]; if (selected?.type === 'hand') { if (!clicked && !checkIllegalDrop(selected.p, r, c)) executeMove(null, null, r, c, selected.p, true); selected = null; } else if (selected) { if (selected.r === r && selected.c === c) selected = null; else if (canMove(board, selected.r, selected.c, r, c, turn)) { executeMove(selected.r, selected.c, r, c, selected.p); selected = null; } else if (clicked && clicked.owner === turn) selected = { r, c, p: clicked.p, type: 'board' }; else selected = null; } else if (clicked && clicked.owner === turn) selected = { r, c, p: clicked.p, type: 'board' }; render(); }
    function getLegalMoves() { if (!selected || result || currentIndex !== history.length-1) return []; let moves = []; for (let r=0; r<9; r++) for (let c=0; c<9; c++) { if (selected.type === 'hand') { if (!board[r][c] && !checkIllegalDrop(selected.p, r, c, true)) moves.push({r, c}); } else { if (canMove(board, selected.r, selected.c, r, c, turn)) moves.push({r, c}); } } return moves; }
    function applyResignResult() { result = (turn==='sente'?'gote_win':'sente_win'); saveHistory(null,null,null,null,"投了"); syncDisplayNames(); }
    function resignGame() { if (result || !confirm("投了しますか？")) return; applyResignResult(); render(); }
    function resetGame() { if (confirm("リセットしますか？")) init(); }
    function updateHandUI(owner, handData) { const container = document.querySelector(`#hand-${owner} .hand-container`); container.innerHTML = ''; for (const [p, count] of Object.entries(handData)) if (count > 0) { const el = document.createElement('div'); el.className = `hand-piece ${owner==='gote'?'p-flip':''}`; el.innerHTML = `${p}${count>1?count:''}`; if (!result && currentIndex === history.length-1) el.onclick = (e) => { e.stopPropagation(); selectHand(p, owner); }; container.appendChild(el); } }
    function selectHand(p, owner) { if (turn === owner) { selected = (selected?.p === p) ? null : { type: 'hand', p, owner }; render(); } }
    function jumpTo(idx) { currentIndex = idx; selected = null; render(); }
    function prevMove() { if (currentIndex > 0) jumpTo(currentIndex - 1); }
    function nextMove() { if (currentIndex < history.length - 1) jumpTo(currentIndex + 1); }
    function toggleRotate() { isRotated = !isRotated; document.getElementById('board').classList.toggle('rotated'); document.getElementById('main-container').classList.toggle('rotated'); render(); }
    function toggleKifu(show) { document.getElementById('kifu-overlay').style.display = show ? 'flex' : 'none'; }
    function updateKifuList() { const log = document.getElementById('kifu-list'); log.innerHTML = ''; history.forEach((h, i) => { const d = document.createElement('div'); d.className = `kifu-line ${i === currentIndex ? 'active' : ''}`; d.textContent = h.moveStr; d.onclick = () => jumpTo(i); log.appendChild(d); }); log.scrollTop = log.scrollHeight; }
    function updateStatus() { const msg = document.getElementById('msg'); if (result) { msg.textContent = "対局終了"; return; } msg.textContent = selected ? `【${selected.p}】の移動先を選択` : (currentIndex < history.length-1 ? "棋譜閲覧中" : (turn==='sente'?'先手番':'後手番')); }
    function openSettings(m) { document.getElementById('modal-overlay').style.display='flex'; if(m==='save'){ document.getElementById('modal-title').textContent="棋譜を保存"; document.getElementById('filename-area').style.display='block'; document.getElementById('save-final-btn').style.display='block'; document.getElementById('filename-input').value = `shogi_${Date.now()}`; } else { document.getElementById('modal-title').textContent="対局設定"; document.getElementById('filename-area').style.display='none'; document.getElementById('save-final-btn').style.display='none'; } }
    function closeSettings() { syncDisplayNames(); document.getElementById('modal-overlay').style.display='none'; }
    function syncDisplayNames() { document.getElementById('name-display-sente').textContent = document.getElementById('sente-input').value || "先手"; document.getElementById('name-display-gote').textContent = document.getElementById('gote-input').value || "後手"; }
    function undoMove() { if (history.length <= 1) return; history.pop(); board = JSON.parse(JSON.stringify(history[history.length-1].board)); hands = JSON.parse(JSON.stringify(history[history.length-1].hands)); turn = history[history.length-1].turn; result = null; currentIndex = history.length - 1; selected = null; updateKifuList(); render(); }
    function checkIllegalDrop(p, r, c, silent = false) { if (p === '歩') for (let i = 0; i < 9; i++) if (board[i][c]?.p === '歩' && board[i][c]?.owner === turn) { if (!silent) alert("二歩"); return true; } if (((p === '歩' || p === '香') && ((turn === 'sente' && r === 0) || (turn === 'gote' && r === 8))) || (p === '桂' && ((turn === 'sente' && r <= 1) || (turn === 'gote' && r >= 7)))) { if (!silent) alert("行き所なし"); return true; } return false; }

    init();
</script>
</body>
</html>
