<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>将棋盤（KIF読込強化・勝敗判定・回転）</title>
    <style>
        :root {
            --board-bg: #f3c77c;
            --line-color: #4e342e;
            --highlight: #fff9c4;
            --valid-move: rgba(100, 255, 100, 0.5);
            --bg-color: #f0f2f5;
            --check-bg: #ffcdd2;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
            background-color: var(--bg-color);
            margin: 0; padding: 5px; height: 100dvh;
            display: flex; flex-direction: column; align-items: center;
            overflow: hidden;
        }
        @media (max-height: 500px) { body { overflow-y: auto; height: auto; display: block; } }

        .meta-info {
            display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 4px;
            width: 100%; max-width: 900px; margin-bottom: 5px; flex-shrink: 0;
        }
        .meta-input { padding: 4px; border: 1px solid #ccc; border-radius: 4px; width: 100%; font-size: 0.8rem; }

        .main-container {
            display: flex; flex-direction: row; gap: 10px;
            width: 100%; max-width: 1000px; flex: 1; min-height: 0; justify-content: center;
        }

        .game-area {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100%; width: 100%; position: relative;
        }

        .hand {
            display: flex; gap: 2px; padding: 4px 8px; background: #eecfa1; border: 1px solid #8d6e63;
            width: 100%; max-width: calc(85vh * 0.9); flex-wrap: wrap; align-items: center; justify-content: center;
            border-radius: 2px; margin: 2px 0; flex-shrink: 0; min-height: 40px; position: relative;
        }
        
        .hand-label { 
            font-size: 0.8rem; font-weight: bold; margin-right: 10px; 
            background: rgba(255,255,255,0.5); padding: 1px 5px; border-radius: 4px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px;
        }
        .point-badge {
            font-size: 0.75rem; background: #fff; border: 1px solid #aaa; padding: 0 4px;
            border-radius: 8px; margin-right: 5px; color: #555;
        }

        .hand-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 2px; }
        .hand-piece { font-size: 1.3rem; cursor: pointer; padding: 0 2px; line-height: 1; position: relative; user-select: none; }
        .hand-piece:hover { background-color: rgba(255,255,255,0.4); }
        .hand-piece.selected { background-color: #fff176; border: 1px solid #fbc02d; border-radius: 4px; }
        .count { font-size: 0.75rem; color: #d32f2f; vertical-align: top; margin-left: 0px; font-weight: bold; }

        .board-wrapper {
            aspect-ratio: 9 / 10; height: 100%; max-height: 85vh; width: auto;
            position: relative; flex-shrink: 1;
        }
        .board-container {
            width: 100%; height: 100%;
            display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
            border: 2px solid var(--line-color); background-color: var(--board-bg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.4s ease;
        }
        .board-container.flipped { transform: rotate(180deg); }

        .cell {
            border: 0.5px solid var(--line-color); display: flex; justify-content: center; align-items: center;
            font-size: clamp(10px, 4.5vmin, 2.2rem); position: relative; cursor: pointer; user-select: none;
        }
        .cell.selected { background-color: var(--highlight); }
        .cell.checked { background-color: var(--check-bg); }
        .cell.valid::after {
            content: ''; position: absolute; width: 30%; height: 30%;
            background-color: #4caf50; border-radius: 50%; opacity: 0.6;
        }
        .piece { font-weight: bold; line-height: 1; pointer-events: none; white-space: nowrap; }
        .sente { color: #000; }
        .gote { color: #000; transform: rotate(180deg); }
        .promoted { color: #d50000; }

        .game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; font-weight: bold; z-index: 10; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; white-space: pre-wrap; text-align: center;
        }
        .game-over-overlay.visible { opacity: 1; pointer-events: auto; }

        .sidebar {
            width: 250px; display: flex; flex-direction: column; gap: 8px;
            background: #fff; padding: 8px; border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); height: 100%; max-height: 85vh;
        }
        .turn-indicator {
            text-align: center; font-weight: bold; padding: 4px;
            background: #eee; border-radius: 4px; font-size: 0.9rem; flex-shrink: 0;
        }
        .kifu-list {
            flex: 1; overflow-y: auto; border: 1px solid #ddd;
            font-size: 0.8rem; padding: 5px; background: #fafafa; font-family: monospace; min-height: 0;
        }
        .kifu-line { padding: 2px 4px; border-bottom: 1px dotted #eee; cursor: pointer; }
        .kifu-line:hover { background-color: #f0f0f0; }
        .kifu-line.current { background-color: #e3f2fd; font-weight: bold; border-left: 3px solid #2196f3; }

        .btn-group { display: flex; gap: 5px; flex-shrink: 0; justify-content: space-between; }
        .btn-group.grid { display: grid; grid-template-columns: 1fr 1fr; }
        
        button {
            padding: 8px; font-size: 0.8rem; cursor: pointer; flex: 1;
            background: #fff; border: 1px solid #bbb; border-radius: 4px;
        }
        button:hover { background: #eee; }
        .btn-save { background-color: #e8f5e9; border-color: #a5d6a7; color: #2e7d32; }
        .btn-resign { background-color: #ffebee; border-color: #ef9a9a; color: #c62828; }
        .btn-draw { background-color: #e3f2fd; border-color: #90caf9; color: #1565c0; }
        
        .playback-controls { display: flex; gap: 2px; margin-top: 5px; }
        .playback-controls button { font-family: monospace; font-weight: bold; }

        @media (max-width: 768px) {
            .meta-info { grid-template-columns: 1fr 1fr; }
            .main-container { flex-direction: column; height: auto; justify-content: flex-start; overflow-y: auto; }
            .game-area { height: auto; flex: none; }
            .board-wrapper { max-height: 55dvh; max-width: 100%; }
            .hand { max-width: 100%; }
            .sidebar { width: 100%; height: auto; max-height: none; flex: 1; min-height: 300px; order: 3; }
        }
    </style>
</head>
<body>

    <div class="meta-info">
        <input type="text" id="meta-event" class="meta-input" placeholder="棋戦名">
        <input type="date" id="meta-date" class="meta-input">
        <input type="text" id="meta-sente" class="meta-input" placeholder="▲先手" oninput="game.updateHandLabels()">
        <input type="text" id="meta-gote" class="meta-input" placeholder="△後手" oninput="game.updateHandLabels()">
    </div>

    <div class="main-container">
        <div class="game-area">
            <div class="hand" id="top-hand-area">
                <span class="hand-label" id="top-hand-label">△後手</span>
                <span class="point-badge" id="top-hand-points">0点</span>
            </div>

            <div class="board-wrapper">
                <div class="board-container" id="board"></div>
                <div class="game-over-overlay" id="game-over-msg"></div>
            </div>

            <div class="hand" id="bottom-hand-area">
                <span class="hand-label" id="bottom-hand-label">▲先手</span>
                <span class="point-badge" id="bottom-hand-points">0点</span>
            </div>
        </div>

        <div class="sidebar">
            <div class="turn-indicator" id="turn-display">開始前</div>
            <div class="kifu-list" id="kifu-list"></div>

            <div class="playback-controls">
                <button onclick="game.goto(0)">|&lt;</button>
                <button onclick="game.prev()">&lt;</button>
                <button onclick="game.next()">&gt;</button>
                <button onclick="game.goto(-1)">&gt;|</button>
            </div>

            <div class="btn-group" style="margin-top:5px;">
                <button class="btn-resign" onclick="game.resign()">投了</button>
                <button class="btn-draw" onclick="game.jishogi()">持将棋</button>
            </div>

            <div class="btn-group grid" style="margin-top:5px;">
                <button onclick="game.rotateBoard()">盤面回転 ↻</button>
                <button class="btn-save" onclick="game.downloadKIF()">KIF保存</button>
            </div>
            
            <div class="btn-group grid" style="margin-top:5px;">
                <button onclick="document.getElementById('file-input').click()">読込</button>
                <button class="btn-reset" onclick="if(confirm('初期化しますか？')) game.init()">リセット</button>
                <input type="file" id="file-input" accept=".kif,.kifu,.txt" style="display:none" onchange="game.handleFileSelect(event)">
            </div>
        </div>

        <div style="display:none;">
            <div id="hand-sente-container" class="hand-container" onclick="game.onHandClick('sente', event)"></div>
            <div id="hand-gote-container" class="hand-container" onclick="game.onHandClick('gote', event)"></div>
        </div>
    </div>

<script>
    const PIECE_NAMES = { FU:'歩', KY:'香', KE:'桂', GI:'銀', KI:'金', KA:'角', HI:'飛', OU:'玉', TO:'と', NY:'杏', NK:'圭', NG:'全', UM:'馬', RY:'龍' };
    const PIECE_POINTS = { FU:1, KY:1, KE:1, GI:1, KI:1, KA:5, HI:5, OU:0, TO:1, NY:1, NK:1, NG:1, UM:5, RY:5 };
    const NUM_KANJI = ['〇','一','二','三','四','五','六','七','八','九'];
    const NUM_ZENKAKU = ['０','１','２','３','４','５','６','７','８','９'];
    const MOVES = {
        FU: { step: [[-1, 0]] }, KY: { slide: [[-1, 0]] }, KE: { step: [[-2, -1], [-2, 1]] },
        GI: { step: [[-1, -1], [-1, 0], [-1, 1], [1, -1], [1, 1]] },
        KI: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        OU: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] },
        KA: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }, HI: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        TO: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NY: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NK: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NG: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        UM: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]], step: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        RY: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]], step: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }
    };

    class ShogiGame {
        constructor() {
            this.states = [];
            this.currentStep = 0;
            this.history = [];
            this.viewpoint = 'sente';
            this.selected = null;
            this.validMoves = [];
            
            document.getElementById('meta-date').valueAsDate = new Date();
            this.init();
        }

        init() {
            const board = this.createBoard();
            const hands = { sente: {}, gote: {} };
            this.states = [{ 
                board: board, hands: hands, turn: 'sente', 
                lastTo: null, isGameOver: false, msg: "",
                posHash: ""
            }];
            this.states[0].posHash = this.generateHash(this.states[0]);
            
            this.history = [];
            this.currentStep = 0;
            this.viewpoint = 'sente';
            this.updateViewpointDOM();
            this.deselect();
            this.updateView();
            document.getElementById('game-over-msg').classList.remove('visible');
        }

        createBoard() {
            const b = Array(9).fill(null).map(() => Array(9).fill(null));
            const set = (r, c, type, owner) => b[r][c] = { type, owner, promoted: false };
            set(0,0,'KY','gote'); set(0,1,'KE','gote'); set(0,2,'GI','gote'); set(0,3,'KI','gote'); set(0,4,'OU','gote'); set(0,5,'KI','gote'); set(0,6,'GI','gote'); set(0,7,'KE','gote'); set(0,8,'KY','gote');
            set(1,1,'HI','gote'); set(1,7,'KA','gote');
            for(let i=0; i<9; i++) set(2,i,'FU','gote');
            for(let i=0; i<9; i++) set(6,i,'FU','sente');
            set(7,1,'KA','sente'); set(7,7,'HI','sente');
            set(8,0,'KY','sente'); set(8,1,'KE','sente'); set(8,2,'GI','sente'); set(8,3,'KI','sente'); set(8,4,'OU','sente'); set(8,5,'KI','sente'); set(8,6,'GI','sente'); set(8,7,'KE','sente'); set(8,8,'KY','sente');
            return b;
        }

        get currentState() { return this.states[this.currentStep]; }
        get board() { return this.currentState.board; }
        get hands() { return this.currentState.hands; }
        get turn() { return this.currentState.turn; }

        updateHandLabels() {
            const senteName = document.getElementById('meta-sente').value || "先手";
            const goteName = document.getElementById('meta-gote').value || "後手";
            
            const topLabel = document.getElementById('top-hand-label');
            const topPoints = document.getElementById('top-hand-points');
            const btmLabel = document.getElementById('bottom-hand-label');
            const btmPoints = document.getElementById('bottom-hand-points');

            const senteP = this.calculatePoints('sente');
            const goteP = this.calculatePoints('gote');

            if (this.viewpoint === 'sente') {
                topLabel.innerText = "△" + goteName; topPoints.innerText = goteP + "点";
                btmLabel.innerText = "▲" + senteName; btmPoints.innerText = senteP + "点";
            } else {
                topLabel.innerText = "▲" + senteName; topPoints.innerText = senteP + "点";
                btmLabel.innerText = "△" + goteName; btmPoints.innerText = goteP + "点";
            }
        }

        calculatePoints(owner) {
            let p = 0;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const pc = this.board[r][c]; if(pc && pc.owner === owner) p += PIECE_POINTS[pc.type]; } }
            for(const [type, count] of Object.entries(this.hands[owner])) { if(count>0) p += (PIECE_POINTS[type] * count); }
            return p;
        }

        rotateBoard() {
            this.viewpoint = this.viewpoint === 'sente' ? 'gote' : 'sente';
            this.updateViewpointDOM();
        }

        updateViewpointDOM() {
            const boardEl = document.getElementById('board');
            const topArea = document.getElementById('top-hand-area');
            const btmArea = document.getElementById('bottom-hand-area');
            const handSente = document.getElementById('hand-sente-container');
            const handGote = document.getElementById('hand-gote-container');
            if (this.viewpoint === 'gote') {
                boardEl.classList.add('flipped');
                topArea.appendChild(handSente);
                btmArea.appendChild(handGote);
            } else {
                boardEl.classList.remove('flipped');
                topArea.appendChild(handGote);
                btmArea.appendChild(handSente);
            }
            this.updateHandLabels();
        }

        onCellClick(r, c) {
            if (this.currentState.isGameOver) return;
            const move = this.validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                this.performMoveUI(move);
            } else {
                const piece = this.board[r][c];
                if (piece && piece.owner === this.turn) {
                    this.selected = { type: 'board', r, c, piece };
                    this.validMoves = this.getLegalMoves(r, c, piece);
                    this.render();
                } else {
                    this.deselect();
                }
            }
        }

        onHandClick(owner, e) {
            if (this.currentState.isGameOver) return;
            const target = e.target.closest('.hand-piece');
            if (!target || owner !== this.turn) return;
            const type = target.dataset.type;
            if (!this.hands[owner][type]) return;
            this.selected = { type: 'hand', pieceType: type, owner: owner };
            this.validMoves = this.getLegalDropMoves(type, owner);
            this.render();
        }

        deselect() { this.selected = null; this.validMoves = []; this.render(); }

        performMoveUI(move) {
            if (this.currentStep < this.states.length - 1) {
                this.states = this.states.slice(0, this.currentStep + 1);
                this.history = this.history.slice(0, this.currentStep);
            }
            const nextState = JSON.parse(JSON.stringify(this.currentState));
            let moveText = "";
            let promoted = false;
            let fromStr = "";
            const { r: toR, c: toC } = move;

            if (this.selected.type === 'board') {
                const { r: fromR, c: fromC } = this.selected;
                const piece = nextState.board[fromR][fromC];
                const isPromotable = ["FU","KY","KE","GI","KA","HI"].includes(piece.type) && !piece.promoted;
                const inZone = (this.turn === 'sente' && (toR <= 2 || fromR <= 2)) || (this.turn === 'gote' && (toR >= 6 || fromR >= 6));
                if (isPromotable && inZone) { if (confirm("成りますか？")) promoted = true; }

                const target = nextState.board[toR][toC];
                if (target) {
                    const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                    const rawType = demoteMap[target.type] || target.type;
                    if (!nextState.hands[this.turn][rawType]) nextState.hands[this.turn][rawType] = 0;
                    nextState.hands[this.turn][rawType]++;
                }
                nextState.board[fromR][fromC] = null;
                piece.promoted = piece.promoted || promoted;
                if (promoted) piece.type = this.promoteType(piece.type);
                nextState.board[toR][toC] = piece;
                fromStr = `(${9-fromC}${fromR+1})`;
                moveText = this.generateKifuText(toR, toC, piece.type, promoted, false, fromStr, nextState.lastTo);
            } else {
                const { pieceType } = this.selected;
                nextState.hands[this.turn][pieceType]--;
                nextState.board[toR][toC] = { type: pieceType, owner: this.turn, promoted: false };
                moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
            }
            
            nextState.turn = this.turn === 'sente' ? 'gote' : 'sente';
            nextState.lastTo = { r: toR, c: toC };
            nextState.posHash = this.generateHash(nextState);

            if (this.checkSennichite(nextState)) {
                moveText += " (千日手)";
                nextState.isGameOver = true;
                nextState.msg = "千日手\n引き分け";
            } else if (this.checkMateStatus(nextState)) {
                moveText += " (詰み)";
                nextState.isGameOver = true;
                const winnerName = this.turn === 'sente' ? (document.getElementById('meta-sente').value||'先手') : (document.getElementById('meta-gote').value||'後手');
                nextState.msg = `${winnerName} 勝\n(詰み)`;
            }

            this.states.push(nextState);
            this.history.push(moveText);
            this.currentStep++;
            this.deselect();
            this.updateView();
        }

        generateHash(state) { return JSON.stringify({b:state.board, h:state.hands, t:state.turn}); }
        
        checkSennichite(state) {
            const currentHash = state.posHash;
            let count = 0;
            for (const s of this.states) { if (s.posHash === currentHash) count++; }
            return count >= 3; 
        }

        checkMateStatus(state) {
            const turn = state.turn; 
            if (!this.isKingInCheck(state.board, turn)) return false;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const p = state.board[r][c];
                    if (p && p.owner === turn) {
                        const moves = this.getBoardMoves(r, c, p, state.board);
                        for (const m of moves) {
                            if (!this.willBeCheckedInternal(state.board, r, c, m.r, m.c, turn, false)) return false;
                        }
                    }
                }
            }
            for (const type of Object.keys(state.hands[turn])) {
                if (state.hands[turn][type] > 0) {
                    const drops = this.getDropMoves(type, turn, state.board);
                    for (const d of drops) {
                        if (!this.willBeCheckedInternal(state.board, null, null, d.r, d.c, turn, true, type)) return false;
                    }
                }
            }
            return true;
        }

        isKingInCheck(board, owner) {
            let kR = -1, kC = -1;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if(p && p.type === 'OU' && p.owner === owner) { kR = r; kC = c; break; } } }
            if (kR === -1) return false;
            const enemy = owner === 'sente' ? 'gote' : 'sente';
            for(let r=0; r<9; r++){
                for(let c=0; c<9; c++){
                    const p = board[r][c];
                    if (p && p.owner === enemy) {
                        const moves = this.getBoardMoves(r, c, p, board);
                        if (moves.some(m => m.r === kR && m.c === kC)) return true;
                    }
                }
            }
            return false;
        }

        getLegalMoves(r, c, piece) {
            const rawMoves = this.getBoardMoves(r, c, piece, this.board);
            return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, r, c, move.r, move.c, piece.owner, false));
        }
        getLegalDropMoves(type, owner) {
            const rawMoves = this.getDropMoves(type, owner, this.board);
            return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, null, null, move.r, move.c, owner, true, type));
        }
        willBeCheckedInternal(board, fromR, fromC, toR, toC, owner, isDrop, dropType) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            if (isDrop) { tempBoard[toR][toC] = { type: dropType, owner: owner, promoted: false }; } 
            else { const p = tempBoard[fromR][fromC]; tempBoard[fromR][fromC] = null; tempBoard[toR][toC] = p; }
            return this.isKingInCheck(tempBoard, owner);
        }
        getBoardMoves(r, c, piece, currentBoard) {
            const moves = []; const def = MOVES[piece.type]; const flip = piece.owner === 'sente' ? 1 : -1;
            const isValid = (nr, nc) => nr >= 0 && nr < 9 && nc >= 0 && nc < 9;
            const isFriend = (nr, nc) => currentBoard[nr][nc] && currentBoard[nr][nc].owner === piece.owner;
            if (def.step) { def.step.forEach(([dr, dc]) => { const nr = r + (dr * flip), nc = c + (dc * flip); if (isValid(nr, nc) && !isFriend(nr, nc)) moves.push({ r: nr, c: nc }); }); }
            if (def.slide) { def.slide.forEach(([dr, dc]) => { let currR = r, currC = c; while(true) { currR += (dr * flip); currC += (dc * flip); if (!isValid(currR, currC) || isFriend(currR, currC)) break; moves.push({ r: currR, c: currC }); if (currentBoard[currR][currC]) break; } }); }
            return moves;
        }
        getDropMoves(type, owner, currentBoard) {
            const moves = [];
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (currentBoard[r][c]) continue; if (type === 'FU' && this.isNifu(c, owner, currentBoard)) continue; if (this.isStuck(r, type, owner)) continue; moves.push({ r, c }); } }
            return moves;
        }
        promoteType(t) { const m = { FU:'TO', KY:'NY', KE:'NK', GI:'NG', KA:'UM', HI:'RY' }; return m[t] || t; }
        isNifu(c, o, b) { for (let r = 0; r < 9; r++) { const p = b[r][c]; if (p && p.owner === o && p.type === 'FU' && !p.promoted) return true; } return false; }
        isStuck(r, t, o) { if (o === 'sente') { if ((t === 'FU' || t === 'KY') && r === 0) return true; if (t === 'KE' && r <= 1) return true; } else { if ((t === 'FU' || t === 'KY') && r === 8) return true; if (t === 'KE' && r >= 7) return true; } return false; }
        
        prev() { if(this.currentStep > 0) { this.currentStep--; this.updateView(); } }
        next() { if(this.currentStep < this.states.length - 1) { this.currentStep++; this.updateView(); } }
        goto(step) { if (step === -1) step = this.states.length - 1; this.currentStep = Math.max(0, Math.min(step, this.states.length - 1)); this.updateView(); }
        
        resign() { 
            if (this.currentState.isGameOver) return; 
            if (!confirm("投了しますか？")) return; 
            const state = JSON.parse(JSON.stringify(this.currentState)); 
            state.isGameOver = true; 
            state.msg = `${this.turn === 'sente' ? (document.getElementById('meta-sente').value||'▲先手') : (document.getElementById('meta-gote').value||'△後手')} 投了`; 
            this.states.push(state); this.history.push("投了"); this.currentStep++; this.updateView(); 
        }
        
        jishogi() {
            if (this.currentState.isGameOver) return;
            if (!confirm("持将棋（引き分け）にしますか？\n（合意が必要です）")) return;
            const state = JSON.parse(JSON.stringify(this.currentState));
            state.isGameOver = true;
            state.msg = "持将棋\n引き分け";
            this.states.push(state); this.history.push("持将棋"); this.currentStep++; this.updateView();
        }

        updateView() { this.render(); this.renderKifuList(); this.updateStatus(); this.updateHandLabels(); const overlay = document.getElementById('game-over-msg'); if (this.currentState.isGameOver) { overlay.innerText = this.currentState.msg; overlay.classList.add('visible'); } else { overlay.classList.remove('visible'); } }
        
        render() {
            const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
            let checkedPos = null;
            if (this.isKingInCheck(this.board, this.turn)) {
                for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = this.board[r][c]; if(p && p.type === 'OU' && p.owner === this.turn) { checkedPos = {r,c}; break; } } }
            }
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const cell = document.createElement('div'); cell.className = 'cell'; if (this.selected && this.selected.type === 'board' && this.selected.r === r && this.selected.c === c) cell.classList.add('selected'); if (this.validMoves.some(m => m.r === r && m.c === c)) cell.classList.add('valid'); 
            if (checkedPos && checkedPos.r === r && checkedPos.c === c) cell.classList.add('checked');
            cell.onclick = () => this.onCellClick(r, c); const p = this.board[r][c]; if (p) { const span = document.createElement('span'); span.className = `piece ${p.owner} ${p.promoted ? 'promoted' : ''}`; span.innerText = PIECE_NAMES[p.type]; cell.appendChild(span); } boardEl.appendChild(cell); } }
            this.renderHand('sente'); this.renderHand('gote');
        }
        renderHand(owner) { const container = document.getElementById(`hand-${owner}-container`); container.innerHTML = ''; for (const [type, count] of Object.entries(this.hands[owner])) { if (count > 0) { const div = document.createElement('div'); div.className = 'hand-piece'; div.dataset.type = type; div.innerHTML = `${PIECE_NAMES[type]}<span class="count">${count>1?count:''}</span>`; if (this.selected && this.selected.type === 'hand' && this.selected.owner === owner && this.selected.pieceType === type) div.classList.add('selected'); container.appendChild(div); } } }
        renderKifuList() { const list = document.getElementById('kifu-list'); list.innerHTML = this.history.map((line, i) => `<div class="kifu-line ${i === this.currentStep - 1 ? 'current' : ''}" onclick="game.goto(${i+1})">${i+1}: ${line}</div>`).join(''); const currentEl = list.querySelector('.current'); if (currentEl) currentEl.scrollIntoView({ block: "center", behavior: "smooth" }); }
        updateStatus() { const el = document.getElementById('turn-display'); if (this.currentState.isGameOver) { el.innerText = "終局"; el.style.borderBottom = "3px solid #555"; } else { const sName = document.getElementById('meta-sente').value || "先手"; const gName = document.getElementById('meta-gote').value || "後手"; el.innerText = `${this.turn === 'sente' ? '▲'+sName : '△'+gName} (${this.currentStep}手)`; el.style.borderBottom = `3px solid ${this.turn === 'sente' ? '#000' : '#d32f2f'}`; } }
        generateKifuText(r, c, type, promoted, isDrop, fromStr, lastTo) { const x = 9 - c; const y = NUM_KANJI[r + 1]; const xStr = NUM_ZENKAKU[x]; let dest = `${xStr}${y}`; if (lastTo && lastTo.r === r && lastTo.c === c) dest = "同　"; let pName = PIECE_NAMES[type]; if (promoted) pName = (type === 'FU' ? 'と' : (type === 'KA' ? '馬' : (type === 'HI' ? '龍' : pName + '成'))); if (promoted && !pName.endsWith('成') && !['と','馬','龍'].includes(pName)) pName += '成'; return `${dest}${pName}${isDrop ? '打' : ''}${fromStr}`; }
        createKIFString() { let kif = `# KIF formated by WebShogi\n`; kif += `開始日時：${document.getElementById('meta-date').value.replace(/-/g, '/')}\n`; kif += `棋戦：${document.getElementById('meta-event').value}\n`; kif += `先手：${document.getElementById('meta-sente').value}\n`; kif += `後手：${document.getElementById('meta-gote').value}\n`; kif += `手数----指手---------消费時間--\n`; this.history.forEach((line, i) => kif += `${String(i + 1).padStart(4, ' ')} ${line}\n`); return kif; }
        downloadKIF() { const blob = new Blob([this.createKIFString()], { type: 'text/plain' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `shogi_${document.getElementById('meta-date').value}.kif`; a.click(); }
        
        handleFileSelect(evt) {
            const file = evt.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const buffer = e.target.result;
                let decoder = new TextDecoder('shift-jis');
                let text = decoder.decode(buffer);
                if (!text.includes('手数') && !text.includes('先手') && !text.includes('1 ')) {
                    decoder = new TextDecoder('utf-8');
                    text = decoder.decode(buffer);
                }
                this.importKIF(text);
            };
            reader.readAsArrayBuffer(file);
        }

        importKIF(text) {
            if(!confirm("現在の盤面を破棄して読み込みますか？")) return;
            this.init();
            const lines = text.split(/\r\n|\n/);
            const moveRegex = /^\s*[0-9]+\s+([１-９1-9同])\s?([一二三四五六七八九1-9　])\s?(.*)/; 
            
            lines.forEach(line => {
                if(line.includes("棋戦：")) document.getElementById('meta-event').value = line.split("：")[1].trim();
                if(line.includes("先手：")) document.getElementById('meta-sente').value = line.split("：")[1].trim();
                if(line.includes("後手：")) document.getElementById('meta-gote').value = line.split("：")[1].trim();
                // 日時修正
                const dateMatch = line.match(/開始日時[：:]\s*(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
                if (dateMatch) {
                    const y = dateMatch[1];
                    const m = dateMatch[2].padStart(2, '0');
                    const d = dateMatch[3].padStart(2, '0');
                    document.getElementById('meta-date').value = `${y}-${m}-${d}`;
                }
            });
            this.updateHandLabels();

            for (let line of lines) {
                const match = line.match(moveRegex);
                if (match) {
                    let toXStr = match[1]; let toYStr = match[2]; let rest = match[3].trim();
                    let toC, toR;
                    if (toXStr === '同') {
                        const lastTo = this.currentState.lastTo; if (!lastTo) continue;
                        toR = lastTo.r; toC = lastTo.c;
                    } else {
                        const x = this.toNum(toXStr); const y = this.kanjiToNum(toYStr);
                        toC = 9 - x; toR = y - 1;
                    }
                    const fromMatch = rest.match(/\((\d)(\d)\)/);
                    const isDrop = rest.includes('打');
                    const isPromote = rest.includes('成') && !rest.includes('成銀') && !rest.includes('成桂') && !rest.includes('成香');
                    let pieceType = 'FU';
                    for (const [key, val] of Object.entries(PIECE_NAMES)) { if (rest.startsWith(val)) { pieceType = key; break; } }
                    if (rest.includes('成銀')) pieceType = 'GI'; if (rest.includes('と')) pieceType = 'FU'; 

                    const nextState = JSON.parse(JSON.stringify(this.currentState));
                    const turn = nextState.turn;
                    let moveText = "";

                    if (isDrop) {
                         nextState.hands[turn][pieceType]--;
                         nextState.board[toR][toC] = { type: pieceType, owner: turn, promoted: false };
                         moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
                    } else {
                        let fromR, fromC;
                        if (fromMatch) { const fx = parseInt(fromMatch[1]); const fy = parseInt(fromMatch[2]); fromC = 9 - fx; fromR = fy - 1; } 
                        else { continue; }
                        const piece = nextState.board[fromR][fromC];
                        const target = nextState.board[toR][toC];
                        if (target) {
                            const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                            const rawType = demoteMap[target.type] || target.type;
                            if (!nextState.hands[turn][rawType]) nextState.hands[turn][rawType] = 0;
                            nextState.hands[turn][rawType]++;
                        }
                        nextState.board[fromR][fromC] = null;
                        piece.promoted = piece.promoted || isPromote;
                        if (isPromote) piece.type = this.promoteType(piece.type);
                        nextState.board[toR][toC] = piece;
                        moveText = line.split('(')[0].trim() + `(${9-fromC}${fromR+1})`;
                    }
                    nextState.turn = turn === 'sente' ? 'gote' : 'sente';
                    nextState.lastTo = { r: toR, c: toC };
                    nextState.posHash = this.generateHash(nextState);

                    if (this.checkSennichite(nextState)) {
                        moveText += " (千日手)";
                        nextState.isGameOver = true;
                        nextState.msg = "千日手\n引き分け";
                    } else if (this.checkMateStatus(nextState)) {
                        moveText += " (詰み)";
                        nextState.isGameOver = true;
                        const winner = turn === 'sente' ? document.getElementById('meta-sente').value : document.getElementById('meta-gote').value;
                        nextState.msg = `${winner||(turn==='sente'?'先手':'後手')} 勝\n(詰み)`;
                    } else if (line.includes("投了")) {
                        nextState.isGameOver = true;
                        nextState.msg = line.split(/\s+/)[1] + " 投了";
                    } else if (line.includes("持将棋") || line.includes("千日手")) {
                        nextState.isGameOver = true;
                        nextState.msg = "引き分け";
                    } else if (line.includes("反則")) {
                        nextState.isGameOver = true;
                        nextState.msg = "反則決着";
                    }

                    this.states.push(nextState);
                    this.history.push(moveText);
                    this.currentStep++;
                }
            }
            this.updateView();
            alert("読み込み完了");
        }
        toNum(str) { const zen = "１２３４５６７８９"; const idx = zen.indexOf(str); return idx >= 0 ? idx + 1 : parseInt(str); }
        kanjiToNum(str) { const k = "一二三四五六七八九"; const idx = k.indexOf(str); return idx >= 0 ? idx + 1 : this.toNum(str); }
    }

    const game = new ShogiGame();
</script>
</body>
</html>
