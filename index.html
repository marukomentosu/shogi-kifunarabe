<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Webå°†æ£‹ï¼ˆ1ç”»é¢é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ï¼‰</title>
    <style>
        :root {
            --board-bg: #f3c77c;
            --line-color: #4e342e;
            --highlight: #fff9c4;
            --valid-move: rgba(100, 255, 100, 0.5);
            --bg-color: #212121; /* èƒŒæ™¯ã‚’ãƒ€ãƒ¼ã‚¯ã«ã—ã¦é›†ä¸­ã—ã‚„ã™ã */
            --check-bg: #ffcdd2;
            --text-color: #eee;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            height: 100dvh; /* ã‚¹ãƒãƒ›ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼å¯¾ç­– */
            display: flex; flex-direction: column;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
        }

        /* --- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒãƒ¼ --- */
        .header-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; background: #333; width: 100%; height: 50px; flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 10;
        }
        .app-title { font-weight: bold; font-size: 1.1rem; }
        .menu-btn {
            background: #444; color: #fff; border: 1px solid #666;
            padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;
        }

        /* --- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« (ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤) --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: flex-start;
            padding: 20px; overflow-y: auto;
            transition: opacity 0.2s; visibility: hidden; opacity: 0;
        }
        .modal.active { visibility: visible; opacity: 1; }
        
        .modal-content {
            background: #fff; color: #333; padding: 20px; border-radius: 8px;
            width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 15px;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 10px; }
        .modal h2 { margin: 0; font-size: 1.2rem; }
        .close-btn { background: transparent; border: none; font-size: 1.5rem; cursor: pointer; }
        
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-size: 0.8rem; font-weight: bold; color: #666; }
        .modal-input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; width: 100%; }
        .date-row { display: flex; gap: 5px; }

        .modal-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .btn-modal { padding: 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .btn-primary { background: #1976d2; color: #fff; border: none; }
        .btn-danger { background: #d32f2f; color: #fff; border: none; }

        /* --- ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ --- */
        .main-container {
            flex: 1; display: flex; flex-direction: column;
            width: 100%; max-width: 800px; margin: 0 auto;
            position: relative; padding: 5px;
            justify-content: space-between; /* ä¸Šä¸‹ã«åˆ†æ•£ */
        }

        /* é§’å° */
        .hand {
            display: flex; align-items: center; justify-content: center;
            background: #eecfa1; color: #000; border: 1px solid #8d6e63;
            width: 100%; min-height: 40px; border-radius: 4px;
            padding: 2px 5px; position: relative;
            flex-shrink: 0;
        }
        .hand-info { position: absolute; left: 5px; top: 2px; font-size: 0.7rem; font-weight: bold; display: flex; flex-direction: column; }
        .hand-label { white-space: nowrap; max-width: 120px; overflow: hidden; text-overflow: ellipsis; }
        .point-badge { font-size: 0.65rem; color: #d32f2f; }
        
        .hand-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 2px; margin-left: 60px; /* infoã®åˆ†ç©ºã‘ã‚‹ */ }
        .hand-piece { font-size: 1.4rem; cursor: pointer; line-height: 1; user-select: none; position: relative; padding: 0 2px; }
        .hand-piece.selected { background-color: #fff176; border-radius: 4px; outline: 2px solid #fbc02d; }
        .count { font-size: 0.7rem; color: #d32f2f; vertical-align: top; font-weight: bold; }

        /* ç›¤é¢ (ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–æœ€å¤§åŒ–) */
        .board-wrapper {
            flex: 1; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ */
            display: flex; justify-content: center; align-items: center;
            position: relative; width: 100%; margin: 5px 0;
            overflow: hidden;
        }
        .board-container {
            /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¤ã¤ã€è¦ªæ ã«åã¾ã‚‹æœ€å¤§ã‚µã‚¤ã‚º */
            aspect-ratio: 9 / 10;
            height: 100%; max-height: 100%; width: auto; max-width: 100%;
            display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
            border: 2px solid var(--line-color); background-color: var(--board-bg);
            transition: transform 0.4s ease;
        }
        .board-container.flipped { transform: rotate(180deg); }

        .cell {
            border: 0.5px solid var(--line-color); display: flex; justify-content: center; align-items: center;
            font-size: clamp(12px, 5vh, 2.5rem); /* æ–‡å­—ã‚µã‚¤ã‚ºè‡ªå‹•èª¿æ•´ */
            position: relative; cursor: pointer; user-select: none; color: #000;
        }
        .cell.selected { background-color: var(--highlight); }
        .cell.checked { background-color: var(--check-bg); }
        .cell.valid::after {
            content: ''; position: absolute; width: 25%; height: 25%;
            background-color: #4caf50; border-radius: 50%; opacity: 0.7;
        }
        .piece { font-weight: bold; line-height: 1; pointer-events: none; white-space: nowrap; font-family: serif; }
        .gote { transform: rotate(180deg); }
        .promoted { color: #d50000; }

        .game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; font-weight: bold; z-index: 10; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; white-space: pre-wrap; text-align: center;
        }
        .game-over-overlay.visible { opacity: 1; pointer-events: auto; }

        /* --- ä¸‹éƒ¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ --- */
        .controls-area {
            background: #333; padding: 5px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 5px; flex-shrink: 0;
        }
        
        .status-bar {
            display: flex; justify-content: space-between; align-items: center; color: #fff; font-size: 0.9rem; padding: 0 5px;
        }
        .kifu-display {
            background: #fff; color: #000; height: 30px; line-height: 30px; padding: 0 10px;
            border-radius: 4px; font-family: monospace; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; flex: 1; margin-right: 10px;
        }

        .playback-controls { display: flex; gap: 2px; width: 100%; }
        .playback-btn {
            flex: 1; padding: 10px 0; cursor: pointer; background: #555; color: #fff; border: 1px solid #666; border-radius: 4px; font-size: 1.2rem;
        }
        .playback-btn:active { background: #777; }

        .action-btns { display: flex; gap: 5px; }
        .sub-btn {
            flex: 1; padding: 8px; font-size: 0.85rem; cursor: pointer; background: #e0e0e0; border: none; border-radius: 4px; color: #333;
        }
    </style>
</head>
<body>

    <div class="header-bar">
        <div class="app-title">Webå°†æ£‹</div>
        <button class="menu-btn" onclick="openModal()">âš™ï¸ è¨­å®šãƒ»ä¿å­˜</button>
    </div>

    <div class="main-container">
        <div class="hand" id="top-hand-area">
            <div class="hand-info">
                <span class="hand-label" id="top-hand-label">â–³å¾Œæ‰‹</span>
                <span class="point-badge" id="top-hand-points">0ç‚¹</span>
            </div>
            </div>

        <div class="board-wrapper">
            <div class="board-container" id="board"></div>
            <div class="game-over-overlay" id="game-over-msg"></div>
        </div>

        <div class="hand" id="bottom-hand-area">
            <div class="hand-info">
                <span class="hand-label" id="bottom-hand-label">â–²å…ˆæ‰‹</span>
                <span class="point-badge" id="bottom-hand-points">0ç‚¹</span>
            </div>
            </div>

        <div class="controls-area">
            <div class="status-bar">
                <div class="kifu-display" id="last-move-display">é–‹å§‹å±€é¢</div>
                <div id="turn-indicator">æ‰‹ç•ª: â–²</div>
            </div>
            <div class="playback-controls">
                <button class="playback-btn" onclick="game.goto(0)">|&lt;</button>
                <button class="playback-btn" onclick="game.prev()">&lt;</button>
                <button class="playback-btn" onclick="game.next()">&gt;</button>
                <button class="playback-btn" onclick="game.goto(-1)">&gt;|</button>
            </div>
            <div class="action-btns">
                <button class="sub-btn" onclick="game.resign()" style="background:#ffcdd2; color:#b71c1c;">æŠ•äº†</button>
                <button class="sub-btn" onclick="game.jishogi()">æŒå°†æ£‹</button>
                <button class="sub-btn" onclick="game.rotateBoard()">å›è»¢</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>å¯¾å±€è¨­å®šãƒ»ä¿å­˜</h2>
                <button class="close-btn" onclick="closeModal()">Ã—</button>
            </div>
            
            <div class="input-group">
                <label>æ£‹æˆ¦å</label>
                <input type="text" id="meta-event" class="modal-input" placeholder="ç·´ç¿’å¯¾å±€">
            </div>
            <div class="input-group">
                <label>æ—¥ä»˜ (å’Œæš¦/è¥¿æš¦)</label>
                <div class="date-row">
                    <input type="text" id="meta-date-text" class="modal-input" placeholder="ä¾‹: R6/10/10">
                    <button onclick="document.getElementById('meta-date-picker').showPicker()" style="padding:0 10px;">ğŸ“…</button>
                    <input type="date" id="meta-date-picker" style="visibility:hidden; position:absolute; width:0;" onchange="game.onDatePicked(this.value)">
                </div>
            </div>
            <div class="input-group">
                <label>â–²å…ˆæ‰‹</label>
                <input type="text" id="meta-sente" class="modal-input" placeholder="å…ˆæ‰‹" oninput="game.updateHandLabels()">
            </div>
            <div class="input-group">
                <label>â–³å¾Œæ‰‹</label>
                <input type="text" id="meta-gote" class="modal-input" placeholder="å¾Œæ‰‹" oninput="game.updateHandLabels()">
            </div>

            <hr style="width:100%; border:0; border-top:1px solid #ddd; margin:10px 0;">

            <div class="modal-actions">
                <button class="btn-modal btn-primary" onclick="game.downloadKIF()">KIFä¿å­˜</button>
                <button class="btn-modal" onclick="document.getElementById('file-input').click()">èª­è¾¼ (KIF)</button>
                <input type="file" id="file-input" accept=".kif,.kifu,.txt" style="display:none" onchange="game.handleFileSelect(event)">
                
                <button class="btn-modal btn-danger" onclick="if(confirm('åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ')){ game.init(); closeModal(); }">ãƒªã‚»ãƒƒãƒˆ</button>
                <button class="btn-modal" onclick="closeModal()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <div style="display:none;">
        <div id="hand-sente-container" class="hand-container" onclick="game.onHandClick('sente', event)"></div>
        <div id="hand-gote-container" class="hand-container" onclick="game.onHandClick('gote', event)"></div>
    </div>

<script>
    // --- ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡ ---
    function openModal() { document.getElementById('settings-modal').classList.add('active'); }
    function closeModal() { document.getElementById('settings-modal').classList.remove('active'); }

    // --- ã‚²ãƒ¼ãƒ å®šæ•° ---
    const PIECE_NAMES = { FU:'æ­©', KY:'é¦™', KE:'æ¡‚', GI:'éŠ€', KI:'é‡‘', KA:'è§’', HI:'é£›', OU:'ç‰', TO:'ã¨', NY:'æ', NK:'åœ­', NG:'å…¨', UM:'é¦¬', RY:'é¾' };
    const PIECE_POINTS = { FU:1, KY:1, KE:1, GI:1, KI:1, KA:5, HI:5, OU:0, TO:1, NY:1, NK:1, NG:1, UM:5, RY:5 };
    const NUM_KANJI = ['ã€‡','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','ä¸ƒ','å…«','ä¹'];
    const NUM_ZENKAKU = ['ï¼','ï¼‘','ï¼’','ï¼“','ï¼”','ï¼•','ï¼–','ï¼—','ï¼˜','ï¼™'];
    const MOVES = {
        FU: { step: [[-1, 0]] }, KY: { slide: [[-1, 0]] }, KE: { step: [[-2, -1], [-2, 1]] },
        GI: { step: [[-1, -1], [-1, 0], [-1, 1], [1, -1], [1, 1]] },
        KI: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        OU: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] },
        KA: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }, HI: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        TO: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NY: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NK: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NG: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        UM: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]], step: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        RY: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]], step: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }
    };

    class ShogiGame {
        constructor() {
            this.states = [];
            this.currentStep = 0;
            this.history = [];
            this.viewpoint = 'sente';
            this.selected = null;
            this.validMoves = [];
            
            // åˆæœŸæ—¥ä»˜
            const today = new Date();
            const y = today.getFullYear();
            const m = String(today.getMonth()+1).padStart(2,'0');
            const d = String(today.getDate()).padStart(2,'0');
            document.getElementById('meta-date-text').value = `${y}/${m}/${d}`;
            
            this.init();
        }

        init() {
            const board = this.createBoard();
            const hands = { sente: {}, gote: {} };
            this.states = [{ 
                board: board, hands: hands, turn: 'sente', 
                lastTo: null, isGameOver: false, msg: "", posHash: ""
            }];
            this.states[0].posHash = this.generateHash(this.states[0]);
            this.history = [];
            this.currentStep = 0;
            this.viewpoint = 'sente';
            this.updateViewpointDOM();
            this.deselect();
            this.updateView();
            document.getElementById('game-over-msg').classList.remove('visible');
        }

        createBoard() {
            const b = Array(9).fill(null).map(() => Array(9).fill(null));
            const set = (r, c, type, owner) => b[r][c] = { type, owner, promoted: false };
            set(0,0,'KY','gote'); set(0,1,'KE','gote'); set(0,2,'GI','gote'); set(0,3,'KI','gote'); set(0,4,'OU','gote'); set(0,5,'KI','gote'); set(0,6,'GI','gote'); set(0,7,'KE','gote'); set(0,8,'KY','gote');
            set(1,1,'HI','gote'); set(1,7,'KA','gote');
            for(let i=0; i<9; i++) set(2,i,'FU','gote');
            for(let i=0; i<9; i++) set(6,i,'FU','sente');
            set(7,1,'KA','sente'); set(7,7,'HI','sente');
            set(8,0,'KY','sente'); set(8,1,'KE','sente'); set(8,2,'GI','sente'); set(8,3,'KI','sente'); set(8,4,'OU','sente'); set(8,5,'KI','sente'); set(8,6,'GI','sente'); set(8,7,'KE','sente'); set(8,8,'KY','sente');
            return b;
        }

        get currentState() { return this.states[this.currentStep]; }
        get board() { return this.currentState.board; }
        get hands() { return this.currentState.hands; }
        get turn() { return this.currentState.turn; }

        // --- æ—¥ä»˜ ---
        onDatePicked(val) { if(val) document.getElementById('meta-date-text').value = val.replace(/-/g, '/'); }
        formatDateForKIF(input) {
            let str = input.trim().replace(/[ï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            const eraMap = { 'M':1868, 'T':1912, 'S':1926, 'H':1989, 'R':2019, 'æ˜æ²»':1868, 'å¤§æ­£':1912, 'æ˜­å’Œ':1926, 'å¹³æˆ':1989, 'ä»¤å’Œ':2019 };
            const warekiRegex = /^([A-Za-z]+|[^\x01-\x7E]+)(\d+)[./å¹´\-](\d+)[./æœˆ\-](\d+)/;
            const match = str.match(warekiRegex);
            if (match) {
                const eraStr = match[1];
                const eraYear = parseInt(match[2]);
                const m = parseInt(match[3]);
                const d = parseInt(match[4]);
                let offset = 0;
                for (const [key, val] of Object.entries(eraMap)) {
                    if (eraStr.toUpperCase().startsWith(key) || eraStr === key) { offset = val; break; }
                }
                if (offset > 0) {
                    const year = offset + eraYear - 1;
                    return `${year}/${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}`;
                }
            }
            const seirekiMatch = str.match(/(\d{4})[./\-](\d{1,2})[./\-](\d{1,2})/);
            if (seirekiMatch) return `${seirekiMatch[1]}/${String(seirekiMatch[2]).padStart(2,'0')}/${String(seirekiMatch[3]).padStart(2,'0')}`;
            return str;
        }

        // --- è¡¨ç¤ºæ›´æ–° ---
        updateHandLabels() {
            const senteName = document.getElementById('meta-sente').value || "å…ˆæ‰‹";
            const goteName = document.getElementById('meta-gote').value || "å¾Œæ‰‹";
            const topLabel = document.getElementById('top-hand-label');
            const topPoints = document.getElementById('top-hand-points');
            const btmLabel = document.getElementById('bottom-hand-label');
            const btmPoints = document.getElementById('bottom-hand-points');
            const senteP = this.calculatePoints('sente');
            const goteP = this.calculatePoints('gote');

            if (this.viewpoint === 'sente') {
                topLabel.innerText = "â–³" + goteName; topPoints.innerText = goteP + "ç‚¹";
                btmLabel.innerText = "â–²" + senteName; btmPoints.innerText = senteP + "ç‚¹";
            } else {
                topLabel.innerText = "â–²" + senteName; topPoints.innerText = senteP + "ç‚¹";
                btmLabel.innerText = "â–³" + goteName; btmPoints.innerText = goteP + "ç‚¹";
            }
        }
        calculatePoints(owner) {
            let p = 0;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const pc = this.board[r][c]; if(pc && pc.owner === owner) p += PIECE_POINTS[pc.type]; } }
            for(const [type, count] of Object.entries(this.hands[owner])) { if(count>0) p += (PIECE_POINTS[type] * count); }
            return p;
        }
        rotateBoard() { this.viewpoint = this.viewpoint === 'sente' ? 'gote' : 'sente'; this.updateViewpointDOM(); }
        updateViewpointDOM() {
            const boardEl = document.getElementById('board');
            const topArea = document.getElementById('top-hand-area');
            const btmArea = document.getElementById('bottom-hand-area');
            const handSente = document.getElementById('hand-sente-container');
            const handGote = document.getElementById('hand-gote-container');
            if (this.viewpoint === 'gote') {
                boardEl.classList.add('flipped');
                topArea.appendChild(handSente); btmArea.appendChild(handGote);
            } else {
                boardEl.classList.remove('flipped');
                topArea.appendChild(handGote); btmArea.appendChild(handSente);
            }
            this.updateHandLabels();
        }

        // --- æ“ä½œ ---
        onCellClick(r, c) {
            if (this.currentState.isGameOver) return;
            const move = this.validMoves.find(m => m.r === r && m.c === c);
            if (move) { this.performMoveUI(move); } 
            else {
                const piece = this.board[r][c];
                if (piece && piece.owner === this.turn) {
                    this.selected = { type: 'board', r, c, piece };
                    this.validMoves = this.getLegalMoves(r, c, piece);
                    this.render();
                } else { this.deselect(); }
            }
        }
        onHandClick(owner, e) {
            if (this.currentState.isGameOver) return;
            const target = e.target.closest('.hand-piece');
            if (!target || owner !== this.turn) return;
            const type = target.dataset.type;
            if (!this.hands[owner][type]) return;
            this.selected = { type: 'hand', pieceType: type, owner: owner };
            this.validMoves = this.getLegalDropMoves(type, owner);
            this.render();
        }
        deselect() { this.selected = null; this.validMoves = []; this.render(); }

        performMoveUI(move) {
            if (this.currentStep < this.states.length - 1) {
                this.states = this.states.slice(0, this.currentStep + 1);
                this.history = this.history.slice(0, this.currentStep);
            }
            const nextState = JSON.parse(JSON.stringify(this.currentState));
            let moveText = ""; let promoted = false; let fromStr = "";
            const { r: toR, c: toC } = move;

            if (this.selected.type === 'board') {
                const { r: fromR, c: fromC } = this.selected;
                const piece = nextState.board[fromR][fromC];
                const isPromotable = ["FU","KY","KE","GI","KA","HI"].includes(piece.type) && !piece.promoted;
                const inZone = (this.turn === 'sente' && (toR <= 2 || fromR <= 2)) || (this.turn === 'gote' && (toR >= 6 || fromR >= 6));
                if (isPromotable && inZone) { if (confirm("æˆã‚Šã¾ã™ã‹ï¼Ÿ")) promoted = true; }
                const target = nextState.board[toR][toC];
                if (target) {
                    const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                    const rawType = demoteMap[target.type] || target.type;
                    if (!nextState.hands[this.turn][rawType]) nextState.hands[this.turn][rawType] = 0;
                    nextState.hands[this.turn][rawType]++;
                }
                nextState.board[fromR][fromC] = null;
                piece.promoted = piece.promoted || promoted;
                if (promoted) piece.type = this.promoteType(piece.type);
                nextState.board[toR][toC] = piece;
                fromStr = `(${9-fromC}${fromR+1})`;
                moveText = this.generateKifuText(toR, toC, piece.type, promoted, false, fromStr, nextState.lastTo);
            } else {
                const { pieceType } = this.selected;
                nextState.hands[this.turn][pieceType]--;
                nextState.board[toR][toC] = { type: pieceType, owner: this.turn, promoted: false };
                moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
            }
            
            nextState.turn = this.turn === 'sente' ? 'gote' : 'sente';
            nextState.lastTo = { r: toR, c: toC };
            nextState.posHash = this.generateHash(nextState);

            if (this.checkSennichite(nextState)) {
                moveText += " (åƒæ—¥æ‰‹)"; nextState.isGameOver = true; nextState.msg = "åƒæ—¥æ‰‹\nå¼•ãåˆ†ã‘";
            } else if (this.checkMateStatus(nextState)) {
                moveText += " (è©°ã¿)"; nextState.isGameOver = true;
                const winnerName = this.turn === 'sente' ? (document.getElementById('meta-sente').value||'å…ˆæ‰‹') : (document.getElementById('meta-gote').value||'å¾Œæ‰‹');
                nextState.msg = `${winnerName} å‹\n(è©°ã¿)`;
            }

            this.states.push(nextState);
            this.history.push(moveText);
            this.currentStep++;
            this.deselect();
            this.updateView();
        }

        // --- åˆ¤å®š ---
        generateHash(state) { return JSON.stringify({b:state.board, h:state.hands, t:state.turn}); }
        checkSennichite(state) {
            const currentHash = state.posHash;
            let count = 0;
            for (const s of this.states) { if (s.posHash === currentHash) count++; }
            return count >= 3; 
        }
        checkMateStatus(state) {
            const turn = state.turn; if (!this.isKingInCheck(state.board, turn)) return false;
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const p = state.board[r][c]; if (p && p.owner === turn) { const moves = this.getBoardMoves(r, c, p, state.board); for (const m of moves) { if (!this.willBeCheckedInternal(state.board, r, c, m.r, m.c, turn, false)) return false; } } } }
            for (const type of Object.keys(state.hands[turn])) { if (state.hands[turn][type] > 0) { const drops = this.getDropMoves(type, turn, state.board); for (const d of drops) { if (!this.willBeCheckedInternal(state.board, null, null, d.r, d.c, turn, true, type)) return false; } } }
            return true;
        }
        isKingInCheck(board, owner) {
            let kR = -1, kC = -1;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if(p && p.type === 'OU' && p.owner === owner) { kR = r; kC = c; break; } } }
            if (kR === -1) return false;
            const enemy = owner === 'sente' ? 'gote' : 'sente';
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if (p && p.owner === enemy) { const moves = this.getBoardMoves(r, c, p, board); if (moves.some(m => m.r === kR && m.c === kC)) return true; } } }
            return false;
        }
        getLegalMoves(r, c, piece) { const rawMoves = this.getBoardMoves(r, c, piece, this.board); return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, r, c, move.r, move.c, piece.owner, false)); }
        getLegalDropMoves(type, owner) { const rawMoves = this.getDropMoves(type, owner, this.board); return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, null, null, move.r, move.c, owner, true, type)); }
        willBeCheckedInternal(board, fromR, fromC, toR, toC, owner, isDrop, dropType) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            if (isDrop) { tempBoard[toR][toC] = { type: dropType, owner: owner, promoted: false }; } else { const p = tempBoard[fromR][fromC]; tempBoard[fromR][fromC] = null; tempBoard[toR][toC] = p; }
            return this.isKingInCheck(tempBoard, owner);
        }
        getBoardMoves(r, c, piece, currentBoard) {
            const moves = []; const def = MOVES[piece.type]; const flip = piece.owner === 'sente' ? 1 : -1;
            const isValid = (nr, nc) => nr >= 0 && nr < 9 && nc >= 0 && nc < 9;
            const isFriend = (nr, nc) => currentBoard[nr][nc] && currentBoard[nr][nc].owner === piece.owner;
            if (def.step) { def.step.forEach(([dr, dc]) => { const nr = r + (dr * flip), nc = c + (dc * flip); if (isValid(nr, nc) && !isFriend(nr, nc)) moves.push({ r: nr, c: nc }); }); }
            if (def.slide) { def.slide.forEach(([dr, dc]) => { let currR = r, currC = c; while(true) { currR += (dr * flip); currC += (dc * flip); if (!isValid(currR, currC) || isFriend(currR, currC)) break; moves.push({ r: currR, c: currC }); if (currentBoard[currR][currC]) break; } }); }
            return moves;
        }
        getDropMoves(type, owner, currentBoard) {
            const moves = [];
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (currentBoard[r][c]) continue; if (type === 'FU' && this.isNifu(c, owner, currentBoard)) continue; if (this.isStuck(r, type, owner)) continue; moves.push({ r, c }); } }
            return moves;
        }
        promoteType(t) { const m = { FU:'TO', KY:'NY', KE:'NK', GI:'NG', KA:'UM', HI:'RY' }; return m[t] || t; }
        isNifu(c, o, b) { for (let r = 0; r < 9; r++) { const p = b[r][c]; if (p && p.owner === o && p.type === 'FU' && !p.promoted) return true; } return false; }
        isStuck(r, t, o) { if (o === 'sente') { if ((t === 'FU' || t === 'KY') && r === 0) return true; if (t === 'KE' && r <= 1) return true; } else { if ((t === 'FU' || t === 'KY') && r === 8) return true; if (t === 'KE' && r >= 7) return true; } return false; }
        
        prev() { if(this.currentStep > 0) { this.currentStep--; this.updateView(); } }
        next() { if(this.currentStep < this.states.length - 1) { this.currentStep++; this.updateView(); } }
        goto(step) { if (step === -1) step = this.states.length - 1; this.currentStep = Math.max(0, Math.min(step, this.states.length - 1)); this.updateView(); }
        resign() { if (this.currentState.isGameOver) return; if (!confirm("æŠ•äº†ã—ã¾ã™ã‹ï¼Ÿ")) return; const state = JSON.parse(JSON.stringify(this.currentState)); state.isGameOver = true; state.msg = `${this.turn === 'sente' ? (document.getElementById('meta-sente').value||'â–²å…ˆæ‰‹') : (document.getElementById('meta-gote').value||'â–³å¾Œæ‰‹')} æŠ•äº†`; this.states.push(state); this.history.push("æŠ•äº†"); this.currentStep++; this.updateView(); }
        jishogi() { if (this.currentState.isGameOver) return; if (!confirm("æŒå°†æ£‹ï¼ˆå¼•ãåˆ†ã‘ï¼‰ã«ã—ã¾ã™ã‹ï¼Ÿ")) return; const state = JSON.parse(JSON.stringify(this.currentState)); state.isGameOver = true; state.msg = "æŒå°†æ£‹\nå¼•ãåˆ†ã‘"; this.states.push(state); this.history.push("æŒå°†æ£‹"); this.currentStep++; this.updateView(); }

        updateView() { 
            this.render(); this.updateHandLabels(); 
            const overlay = document.getElementById('game-over-msg'); 
            if (this.currentState.isGameOver) { overlay.innerText = this.currentState.msg; overlay.classList.add('visible'); } else { overlay.classList.remove('visible'); }
            // ãƒ•ãƒƒã‚¿ãƒ¼è¡¨ç¤ºæ›´æ–°
            document.getElementById('turn-indicator').innerText = `æ‰‹ç•ª: ${this.turn === 'sente' ? 'â–²' : 'â–³'}`;
            if(this.history.length > 0 && this.currentStep > 0) {
                document.getElementById('last-move-display').innerText = `${this.currentStep}: ${this.history[this.currentStep-1]}`;
            } else {
                document.getElementById('last-move-display').innerText = "é–‹å§‹å±€é¢";
            }
        }
        
        render() {
            const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
            let checkedPos = null;
            if (this.isKingInCheck(this.board, this.turn)) { for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = this.board[r][c]; if(p && p.type === 'OU' && p.owner === this.turn) { checkedPos = {r,c}; break; } } } }
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const cell = document.createElement('div'); cell.className = 'cell'; if (this.selected && this.selected.type === 'board' && this.selected.r === r && this.selected.c === c) cell.classList.add('selected'); if (this.validMoves.some(m => m.r === r && m.c === c)) cell.classList.add('valid'); 
            if (checkedPos && checkedPos.r === r && checkedPos.c === c) cell.classList.add('checked');
            cell.onclick = () => this.onCellClick(r, c); const p = this.board[r][c]; if (p) { const span = document.createElement('span'); span.className = `piece ${p.owner} ${p.promoted ? 'promoted' : ''} ${p.owner}`; span.innerText = PIECE_NAMES[p.type]; cell.appendChild(span); } boardEl.appendChild(cell); } }
            this.renderHand('sente'); this.renderHand('gote');
        }
        renderHand(owner) { const container = document.getElementById(`hand-${owner}-container`); container.innerHTML = ''; for (const [type, count] of Object.entries(this.hands[owner])) { if (count > 0) { const div = document.createElement('div'); div.className = 'hand-piece'; div.dataset.type = type; div.innerHTML = `${PIECE_NAMES[type]}<span class="count">${count>1?count:''}</span>`; if (this.selected && this.selected.type === 'hand' && this.selected.owner === owner && this.selected.pieceType === type) div.classList.add('selected'); container.appendChild(div); } } }
        
        generateKifuText(r, c, type, promoted, isDrop, fromStr, lastTo) { const x = 9 - c; const y = NUM_KANJI[r + 1]; const xStr = NUM_ZENKAKU[x]; let dest = `${xStr}${y}`; if (lastTo && lastTo.r === r && lastTo.c === c) dest = "åŒã€€"; let pName = PIECE_NAMES[type]; if (promoted) pName = (type === 'FU' ? 'ã¨' : (type === 'KA' ? 'é¦¬' : (type === 'HI' ? 'é¾' : pName + 'æˆ'))); if (promoted && !pName.endsWith('æˆ') && !['ã¨','é¦¬','é¾'].includes(pName)) pName += 'æˆ'; return `${dest}${pName}${isDrop ? 'æ‰“' : ''}${fromStr}`; }
        createKIFString() { 
            const dRaw = document.getElementById('meta-date-text').value;
            const dFmt = this.formatDateForKIF(dRaw);
            let kif = `# KIF formated by WebShogi\n`; kif += `é–‹å§‹æ—¥æ™‚ï¼š${dFmt}\n`; kif += `æ£‹æˆ¦ï¼š${document.getElementById('meta-event').value}\n`; kif += `å…ˆæ‰‹ï¼š${document.getElementById('meta-sente').value}\n`; kif += `å¾Œæ‰‹ï¼š${document.getElementById('meta-gote').value}\n`; kif += `æ‰‹æ•°----æŒ‡æ‰‹---------æ¶ˆè´¹æ™‚é–“--\n`; this.history.forEach((line, i) => kif += `${String(i + 1).padStart(4, ' ')} ${line}\n`); return kif; 
        }
        downloadKIF() { const blob = new Blob([this.createKIFString()], { type: 'text/plain' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `shogi_${this.formatDateForKIF(document.getElementById('meta-date-text').value).replace(/\//g,'')}.kif`; a.click(); }
        
        handleFileSelect(evt) {
            const file = evt.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const buffer = e.target.result;
                let decoder = new TextDecoder('shift-jis'); let text = decoder.decode(buffer);
                if (!text.includes('æ‰‹æ•°') && !text.includes('å…ˆæ‰‹') && !text.includes('1 ')) { decoder = new TextDecoder('utf-8'); text = decoder.decode(buffer); }
                this.importKIF(text);
                closeModal();
            };
            reader.readAsArrayBuffer(file);
        }

        importKIF(text) {
            if(!confirm("ç¾åœ¨ã®ç›¤é¢ã‚’ç ´æ£„ã—ã¦èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ")) return;
            this.init();
            const lines = text.split(/\r\n|\n/);
            const moveRegex = /^\s*[0-9]+\s+([ï¼‘-ï¼™1-9åŒ])\s?([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹1-9ã€€])\s?(.*)/; 
            lines.forEach(line => {
                if(line.includes("æ£‹æˆ¦ï¼š")) document.getElementById('meta-event').value = line.split("ï¼š")[1].trim();
                if(line.includes("å…ˆæ‰‹ï¼š")) document.getElementById('meta-sente').value = line.split("ï¼š")[1].trim();
                if(line.includes("å¾Œæ‰‹ï¼š")) document.getElementById('meta-gote').value = line.split("ï¼š")[1].trim();
                const dateMatch = line.match(/é–‹å§‹æ—¥æ™‚[ï¼š:]\s*(.+)/);
                if (dateMatch) {
                    const dStr = dateMatch[1].trim();
                    const stdDate = dStr.match(/(\d{4})[./-](\d{1,2})[./-](\d{1,2})/);
                    if(stdDate) document.getElementById('meta-date-text').value = `${stdDate[1]}/${String(stdDate[2]).padStart(2,'0')}/${String(stdDate[3]).padStart(2,'0')}`;
                    else document.getElementById('meta-date-text').value = dStr;
                }
            });
            this.updateHandLabels();

            for (let line of lines) {
                const match = line.match(moveRegex);
                if (match) {
                    let toXStr = match[1]; let toYStr = match[2]; let rest = match[3].trim();
                    let toC, toR;
                    if (toXStr === 'åŒ') { const lastTo = this.currentState.lastTo; if (!lastTo) continue; toR = lastTo.r; toC = lastTo.c; } 
                    else { const x = this.toNum(toXStr); const y = this.kanjiToNum(toYStr); toC = 9 - x; toR = y - 1; }
                    const fromMatch = rest.match(/\((\d)(\d)\)/);
                    const isDrop = rest.includes('æ‰“');
                    const isPromote = rest.includes('æˆ') && !rest.includes('æˆéŠ€') && !rest.includes('æˆæ¡‚') && !rest.includes('æˆé¦™');
                    let pieceType = 'FU';
                    for (const [key, val] of Object.entries(PIECE_NAMES)) { if (rest.startsWith(val)) { pieceType = key; break; } }
                    if (rest.includes('æˆéŠ€')) pieceType = 'GI'; if (rest.includes('ã¨')) pieceType = 'FU'; 

                    const nextState = JSON.parse(JSON.stringify(this.currentState));
                    const turn = nextState.turn;
                    let moveText = "";

                    if (isDrop) {
                         nextState.hands[turn][pieceType]--;
                         nextState.board[toR][toC] = { type: pieceType, owner: turn, promoted: false };
                         moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
                    } else {
                        let fromR, fromC;
                        if (fromMatch) { const fx = parseInt(fromMatch[1]); const fy = parseInt(fromMatch[2]); fromC = 9 - fx; fromR = fy - 1; } else { continue; }
                        const piece = nextState.board[fromR][fromC];
                        const target = nextState.board[toR][toC];
                        if (target) {
                            const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                            const rawType = demoteMap[target.type] || target.type;
                            if (!nextState.hands[turn][rawType]) nextState.hands[turn][rawType] = 0;
                            nextState.hands[turn][rawType]++;
                        }
                        nextState.board[fromR][fromC] = null;
                        piece.promoted = piece.promoted || isPromote;
                        if (isPromote) piece.type = this.promoteType(piece.type);
                        nextState.board[toR][toC] = piece;
                        moveText = line.split('(')[0].trim() + `(${9-fromC}${fromR+1})`;
                    }
                    nextState.turn = turn === 'sente' ? 'gote' : 'sente';
                    nextState.lastTo = { r: toR, c: toC };
                    nextState.posHash = this.generateHash(nextState);

                    if (this.checkSennichite(nextState)) { moveText += " (åƒæ—¥æ‰‹)"; nextState.isGameOver = true; nextState.msg = "åƒæ—¥æ‰‹\nå¼•ãåˆ†ã‘"; } 
                    else if (this.checkMateStatus(nextState)) { moveText += " (è©°ã¿)"; nextState.isGameOver = true; const w = turn==='sente'?document.getElementById('meta-sente').value:document.getElementById('meta-gote').value; nextState.msg = `${w||(turn==='sente'?'å…ˆæ‰‹':'å¾Œæ‰‹')} å‹\n(è©°ã¿)`; }
                    else if (line.includes("æŠ•äº†")) { nextState.isGameOver = true; nextState.msg = line.split(/\s+/)[1] + " æŠ•äº†"; }
                    else if (line.includes("æŒå°†æ£‹") || line.includes("åƒæ—¥æ‰‹")) { nextState.isGameOver = true; nextState.msg = "å¼•ãåˆ†ã‘"; }
                    else if (line.includes("åå‰‡")) { nextState.isGameOver = true; nextState.msg = "åå‰‡æ±ºç€"; }

                    this.states.push(nextState);
                    this.history.push(moveText);
                    this.currentStep++;
                }
            }
            this.updateView();
            alert("èª­ã¿è¾¼ã¿å®Œäº†");
        }
        toNum(str) { const zen = "ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"; const idx = zen.indexOf(str); return idx >= 0 ? idx + 1 : parseInt(str); }
        kanjiToNum(str) { const k = "ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹"; const idx = k.indexOf(str); return idx >= 0 ? idx + 1 : this.toNum(str); }
    }

    const game = new ShogiGame();
</script>
</body>
</html>
