<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebÂ∞ÜÊ£ãÔºà„Çπ„Éû„ÉõÂÆåÂÖ®ÂØæÂøúÁâàÔºâ</title>
    <style>
        :root {
            --board-bg: #f3c77c;
            --line-color: #4e342e;
            --highlight: #fff9c4;
            --valid-move: rgba(100, 255, 100, 0.5);
            --bg-color: #212121;
            --text-color: #eee;
            --check-bg: #ffcdd2;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Yu Mincho", "Hiragino Mincho ProN", serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            height: 100dvh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* „Éò„ÉÉ„ÉÄ„Éº */
        .header-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 12px; background: #333; width: 100%; height: 45px; flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 10;
        }
        .app-title { font-weight: bold; font-size: 1rem; }
        .menu-btn {
            background: #444; color: #fff; border: 1px solid #666;
            padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85rem;
        }

        /* „É¢„Éº„ÉÄ„É´ */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; justify-content: center; align-items: flex-start;
            padding: 10px; overflow-y: auto;
            transition: opacity 0.2s; visibility: hidden; opacity: 0;
        }
        .modal.active { visibility: visible; opacity: 1; }
        
        .modal-content {
            background: #fff; color: #333; padding: 15px; border-radius: 8px;
            width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 10px; margin-top: 20px;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .modal h2 { margin: 0; font-size: 1.1rem; }
        
        .input-group { display: flex; flex-direction: column; gap: 2px; }
        .input-group label { font-size: 0.8rem; font-weight: bold; color: #555; }
        .modal-input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; width: 100%; }
        
        /* „ÉÜ„Ç≠„Çπ„ÉàË≤º„Çä‰ªò„Åë„Ç®„É™„Ç¢ */
        .paste-area {
            width: 100%; height: 80px; border: 1px solid #ccc; border-radius: 4px; 
            font-size: 0.8rem; font-family: monospace; padding: 5px; resize: none;
        }

        .modal-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .btn-modal { padding: 10px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .btn-primary { background: #1976d2; color: #fff; border: none; }
        .btn-danger { background: #d32f2f; color: #fff; border: none; }

        /* „É°„Ç§„É≥„Ç®„É™„Ç¢ */
        .main-container {
            flex: 1; display: flex; flex-direction: column;
            width: 100%; max-width: 800px; margin: 0 auto;
            position: relative; padding: 5px;
            justify-content: space-between;
        }

        /* ÈßíÂè∞ */
        .hand {
            display: flex; align-items: center; justify-content: center;
            background: #eecfa1; color: #000; border: 1px solid #8d6e63;
            width: 100%; min-height: 42px; border-radius: 4px;
            padding: 2px 5px; position: relative; flex-shrink: 0;
        }
        .hand-info { position: absolute; left: 5px; top: 2px; font-size: 0.7rem; font-weight: bold; display: flex; flex-direction: column; pointer-events: none;}
        .hand-label { white-space: nowrap; max-width: 100px; overflow: hidden; text-overflow: ellipsis; }
        .point-badge { font-size: 0.65rem; color: #d32f2f; }
        .hand-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 2px; margin-left: 50px; }
        .hand-piece { font-size: 1.5rem; cursor: pointer; line-height: 1; user-select: none; position: relative; padding: 0 2px; }
        .hand-piece.selected { background-color: #fff176; border-radius: 4px; outline: 2px solid #fbc02d; }
        .count { font-size: 0.75rem; color: #d32f2f; vertical-align: top; font-weight: bold; }

        /* Áõ§Èù¢ */
        .board-wrapper {
            flex: 1; display: flex; justify-content: center; align-items: center;
            position: relative; width: 100%; margin: 5px 0; overflow: hidden;
        }
        .board-container {
            aspect-ratio: 9 / 10; height: 100%; max-height: 100%; width: auto; max-width: 100%;
            display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
            border: 2px solid var(--line-color); background-color: var(--board-bg);
            transition: transform 0.4s ease;
        }
        .board-container.flipped { transform: rotate(180deg); }

        .cell {
            border: 0.5px solid var(--line-color); display: flex; justify-content: center; align-items: center;
            font-size: clamp(12px, 5vh, 2.5rem); position: relative; cursor: pointer; user-select: none; color: #000;
        }
        .cell.selected { background-color: var(--highlight); }
        .cell.checked { background-color: var(--check-bg); }
        .cell.valid::after {
            content: ''; position: absolute; width: 25%; height: 25%;
            background-color: #4caf50; border-radius: 50%; opacity: 0.7;
        }
        .piece { font-weight: bold; line-height: 1; pointer-events: none; white-space: nowrap; font-family: serif; }
        .gote { transform: rotate(180deg); }
        .promoted { color: #d50000; }

        .game-over-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; font-weight: bold; z-index: 10; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; white-space: pre-wrap; text-align: center;
        }
        .game-over-overlay.visible { opacity: 1; pointer-events: auto; }

        /* „Ç≥„É≥„Éà„É≠„Éº„É´ */
        .controls-area {
            background: #333; padding: 5px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 6px; flex-shrink: 0; padding-bottom: 10px;
        }
        .status-bar { display: flex; justify-content: space-between; align-items: center; color: #fff; font-size: 0.85rem; padding: 0 5px; }
        .kifu-display {
            background: #fff; color: #000; height: 28px; line-height: 28px; padding: 0 10px;
            border-radius: 4px; font-family: monospace; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; flex: 1; margin-right: 10px;
        }
        .playback-controls { display: flex; gap: 2px; width: 100%; }
        .playback-btn {
            flex: 1; padding: 8px 0; cursor: pointer; background: #555; color: #fff; border: 1px solid #666; border-radius: 4px; font-size: 1.1rem;
        }
        .action-btns { display: grid; grid-template-columns: 1.2fr 1fr 1fr 1fr; gap: 5px; }
        .sub-btn {
            padding: 10px 0; font-size: 0.9rem; cursor: pointer; background: #e0e0e0; border: none; border-radius: 4px; color: #333; font-weight: bold;
        }
        .btn-matta { background-color: #fff9c4; color: #f57f17; border: 1px solid #fbc02d; }
    </style>
</head>
<body>

    <div class="header-bar">
        <div class="app-title">WebÂ∞ÜÊ£ã</div>
        <button class="menu-btn" onclick="openModal()">‚öôÔ∏è „É°„Éã„É•„Éº</button>
    </div>

    <div class="main-container">
        <div class="hand" id="top-hand-area">
            <div class="hand-info">
                <span class="hand-label" id="top-hand-label">‚ñ≥ÂæåÊâã</span>
                <span class="point-badge" id="top-hand-points">0ÁÇπ</span>
            </div>
        </div>

        <div class="board-wrapper">
            <div class="board-container" id="board"></div>
            <div class="game-over-overlay" id="game-over-msg"></div>
        </div>

        <div class="hand" id="bottom-hand-area">
            <div class="hand-info">
                <span class="hand-label" id="bottom-hand-label">‚ñ≤ÂÖàÊâã</span>
                <span class="point-badge" id="bottom-hand-points">0ÁÇπ</span>
            </div>
        </div>

        <div class="controls-area">
            <div class="status-bar">
                <div class="kifu-display" id="last-move-display">ÈñãÂßãÂ±ÄÈù¢</div>
                <div id="turn-indicator">ÊâãÁï™: ‚ñ≤</div>
            </div>
            <div class="playback-controls">
                <button class="playback-btn" onclick="game.goto(0)">|&lt;</button>
                <button class="playback-btn" onclick="game.prev()">&lt;</button>
                <button class="playback-btn" onclick="game.next()">&gt;</button>
                <button class="playback-btn" onclick="game.goto(-1)">&gt;|</button>
            </div>
            <div class="action-btns">
                <button class="sub-btn btn-matta" onclick="game.undo()">ÂæÖ„Å£„Åü</button>
                <button class="sub-btn" onclick="game.rotateBoard()">ÂõûËª¢</button>
                <button class="sub-btn" onclick="game.jishogi()">ÊåÅÂ∞ÜÊ£ã</button>
                <button class="sub-btn" onclick="game.resign()" style="color:#c62828;">Êäï‰∫Ü</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>„É°„Éã„É•„Éº</h2>
                <button onclick="closeModal()" style="border:none; background:none; font-size:1.5rem;">√ó</button>
            </div>
            
            <div class="input-group">
                <label>Ê£ãÊà¶ / Êó•‰ªò</label>
                <input type="text" id="meta-event" class="modal-input" placeholder="Ê£ãÊà¶Âêç">
                <div style="display:flex; gap:5px;">
                    <input type="text" id="meta-date-text" class="modal-input" placeholder="Êó•‰ªò (R6/10/10)">
                    <input type="date" id="meta-date-picker" style="width:40px;" onchange="game.onDatePicked(this.value)">
                </div>
            </div>
            <div class="input-group" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                    <label>‚ñ≤ÂÖàÊâã</label>
                    <input type="text" id="meta-sente" class="modal-input" placeholder="ÂÖàÊâã" oninput="game.updateHandLabels()">
                </div>
                <div>
                    <label>‚ñ≥ÂæåÊâã</label>
                    <input type="text" id="meta-gote" class="modal-input" placeholder="ÂæåÊâã" oninput="game.updateHandLabels()">
                </div>
            </div>

            <hr style="width:100%; border:0; border-top:1px solid #ddd; margin:5px 0;">

            <div class="input-group">
                <label>Ê£ãË≠úË™≠Ëæº (KIFÂΩ¢Âºè)</label>
                <textarea id="kif-paste-area" class="paste-area" placeholder="„Åì„Åì„Å´KIF„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë"></textarea>
                <button class="btn-modal" onclick="game.loadKIFFromText()" style="background:#eee;">‚Üë „ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâË™≠Ëæº</button>
                
                <div style="text-align:center; margin:5px 0;">„Åæ„Åü„ÅØ</div>
                
                <button class="btn-modal" onclick="document.getElementById('file-input').click()" style="background:#eee;">üìÅ „Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</button>
                <input type="file" id="file-input" accept=".kif,.kifu,.txt,text/*" style="display:none" onchange="game.handleFileSelect(event)">
            </div>

            <div class="modal-actions">
                <button class="btn-modal btn-primary" onclick="game.downloadKIF()">KIF‰øùÂ≠ò</button>
                <button class="btn-modal btn-danger" onclick="if(confirm('ÂàùÊúüÂåñ„Åó„Åæ„Åô„ÅãÔºü')){ game.init(); closeModal(); }">„É™„Çª„ÉÉ„Éà</button>
            </div>
            <button class="btn-modal" onclick="closeModal()" style="width:100%; margin-top:10px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <div style="display:none;">
        <div id="hand-sente-container" class="hand-container" onclick="game.onHandClick('sente', event)"></div>
        <div id="hand-gote-container" class="hand-container" onclick="game.onHandClick('gote', event)"></div>
    </div>

<script>
    function openModal() { document.getElementById('settings-modal').classList.add('active'); }
    function closeModal() { document.getElementById('settings-modal').classList.remove('active'); }

    const PIECE_NAMES = { FU:'Ê≠©', KY:'È¶ô', KE:'Ê°Ç', GI:'ÈäÄ', KI:'Èáë', KA:'Ëßí', HI:'È£õ', OU:'Áéâ', TO:'„Å®', NY:'Êùè', NK:'Âú≠', NG:'ÂÖ®', UM:'È¶¨', RY:'Èæç' };
    const PIECE_POINTS = { FU:1, KY:1, KE:1, GI:1, KI:1, KA:5, HI:5, OU:0, TO:1, NY:1, NK:1, NG:1, UM:5, RY:5 };
    const NUM_KANJI = ['„Äá','‰∏Ä','‰∫å','‰∏â','Âõõ','‰∫î','ÂÖ≠','‰∏É','ÂÖ´','‰πù'];
    const NUM_ZENKAKU = ['Ôºê','Ôºë','Ôºí','Ôºì','Ôºî','Ôºï','Ôºñ','Ôºó','Ôºò','Ôºô'];
    const MOVES = {
        FU: { step: [[-1, 0]] }, KY: { slide: [[-1, 0]] }, KE: { step: [[-2, -1], [-2, 1]] },
        GI: { step: [[-1, -1], [-1, 0], [-1, 1], [1, -1], [1, 1]] },
        KI: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        OU: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] },
        KA: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }, HI: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        TO: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NY: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NK: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        NG: { step: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0]] },
        UM: { slide: [[-1, -1], [-1, 1], [1, -1], [1, 1]], step: [[-1, 0], [1, 0], [0, -1], [0, 1]] },
        RY: { slide: [[-1, 0], [1, 0], [0, -1], [0, 1]], step: [[-1, -1], [-1, 1], [1, -1], [1, 1]] }
    };

    class ShogiGame {
        constructor() {
            this.states = []; this.currentStep = 0; this.history = [];
            this.viewpoint = 'sente'; this.selected = null; this.validMoves = [];
            const t = new Date();
            const y = t.getFullYear(); const m = String(t.getMonth()+1).padStart(2,'0'); const d = String(t.getDate()).padStart(2,'0');
            document.getElementById('meta-date-text').value = `${y}/${m}/${d}`;
            this.init();
        }

        init() {
            const board = this.createBoard();
            const hands = { sente: {}, gote: {} };
            this.states = [{ board: board, hands: hands, turn: 'sente', lastTo: null, isGameOver: false, msg: "", posHash: "" }];
            this.states[0].posHash = this.generateHash(this.states[0]);
            this.history = []; this.currentStep = 0;
            this.viewpoint = 'sente';
            this.updateViewpointDOM(); this.deselect(); this.updateView();
            document.getElementById('game-over-msg').classList.remove('visible');
        }

        createBoard() {
            const b = Array(9).fill(null).map(() => Array(9).fill(null));
            const set = (r, c, type, owner) => b[r][c] = { type, owner, promoted: false };
            set(0,0,'KY','gote'); set(0,1,'KE','gote'); set(0,2,'GI','gote'); set(0,3,'KI','gote'); set(0,4,'OU','gote'); set(0,5,'KI','gote'); set(0,6,'GI','gote'); set(0,7,'KE','gote'); set(0,8,'KY','gote');
            set(1,1,'HI','gote'); set(1,7,'KA','gote');
            for(let i=0; i<9; i++) set(2,i,'FU','gote');
            for(let i=0; i<9; i++) set(6,i,'FU','sente');
            set(7,1,'KA','sente'); set(7,7,'HI','sente');
            set(8,0,'KY','sente'); set(8,1,'KE','sente'); set(8,2,'GI','sente'); set(8,3,'KI','sente'); set(8,4,'OU','sente'); set(8,5,'KI','sente'); set(8,6,'GI','sente'); set(8,7,'KE','sente'); set(8,8,'KY','sente');
            return b;
        }

        get currentState() { return this.states[this.currentStep]; }
        get board() { return this.currentState.board; }
        get hands() { return this.currentState.hands; }
        get turn() { return this.currentState.turn; }

        // --- Êó•‰ªò ---
        onDatePicked(val) { if(val) document.getElementById('meta-date-text').value = val.replace(/-/g, '/'); }
        formatDateForKIF(input) {
            let str = input.trim().replace(/[Ôºê-Ôºô]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            const eraMap = { 'M':1868, 'T':1912, 'S':1926, 'H':1989, 'R':2019, 'ÊòéÊ≤ª':1868, 'Â§ßÊ≠£':1912, 'Êò≠Âíå':1926, 'Âπ≥Êàê':1989, '‰ª§Âíå':2019 };
            const warekiRegex = /^([A-Za-z]+|[^\x01-\x7E]+)(\d+)[./Âπ¥\-](\d+)[./Êúà\-](\d+)/;
            const match = str.match(warekiRegex);
            if (match) {
                let offset = 0;
                for (const [key, val] of Object.entries(eraMap)) { if (match[1].toUpperCase().startsWith(key) || match[1] === key) { offset = val; break; } }
                if (offset > 0) return `${offset + parseInt(match[2]) - 1}/${String(match[3]).padStart(2,'0')}/${String(match[4]).padStart(2,'0')}`;
            }
            const seirekiMatch = str.match(/(\d{4})[./\-](\d{1,2})[./\-](\d{1,2})/);
            if (seirekiMatch) return `${seirekiMatch[1]}/${String(seirekiMatch[2]).padStart(2,'0')}/${String(seirekiMatch[3]).padStart(2,'0')}`;
            return str;
        }

        // --- View Updates ---
        updateHandLabels() {
            const sName = document.getElementById('meta-sente').value || "ÂÖàÊâã";
            const gName = document.getElementById('meta-gote').value || "ÂæåÊâã";
            const sP = this.calculatePoints('sente'); const gP = this.calculatePoints('gote');
            if (this.viewpoint === 'sente') {
                document.getElementById('top-hand-label').innerText = "‚ñ≥" + gName;
                document.getElementById('top-hand-points').innerText = gP + "ÁÇπ";
                document.getElementById('bottom-hand-label').innerText = "‚ñ≤" + sName;
                document.getElementById('bottom-hand-points').innerText = sP + "ÁÇπ";
            } else {
                document.getElementById('top-hand-label').innerText = "‚ñ≤" + sName;
                document.getElementById('top-hand-points').innerText = sP + "ÁÇπ";
                document.getElementById('bottom-hand-label').innerText = "‚ñ≥" + gName;
                document.getElementById('bottom-hand-points').innerText = gP + "ÁÇπ";
            }
        }
        calculatePoints(owner) {
            let p = 0;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const pc = this.board[r][c]; if(pc && pc.owner === owner) p += PIECE_POINTS[pc.type]; } }
            for(const [type, count] of Object.entries(this.hands[owner])) { if(count>0) p += (PIECE_POINTS[type] * count); }
            return p;
        }
        rotateBoard() { this.viewpoint = this.viewpoint === 'sente' ? 'gote' : 'sente'; this.updateViewpointDOM(); }
        updateViewpointDOM() {
            const boardEl = document.getElementById('board');
            const topArea = document.getElementById('top-hand-area');
            const btmArea = document.getElementById('bottom-hand-area');
            const handSente = document.getElementById('hand-sente-container');
            const handGote = document.getElementById('hand-gote-container');
            if (this.viewpoint === 'gote') {
                boardEl.classList.add('flipped'); topArea.appendChild(handSente); btmArea.appendChild(handGote);
            } else {
                boardEl.classList.remove('flipped'); topArea.appendChild(handGote); btmArea.appendChild(handSente);
            }
            this.updateHandLabels();
        }

        // --- Core Logic ---
        onCellClick(r, c) {
            if (this.currentState.isGameOver) return;
            const move = this.validMoves.find(m => m.r === r && m.c === c);
            if (move) this.performMoveUI(move);
            else {
                const piece = this.board[r][c];
                if (piece && piece.owner === this.turn) {
                    this.selected = { type: 'board', r, c, piece };
                    this.validMoves = this.getLegalMoves(r, c, piece);
                    this.render();
                } else this.deselect();
            }
        }
        onHandClick(owner, e) {
            if (this.currentState.isGameOver) return;
            const target = e.target.closest('.hand-piece');
            if (!target || owner !== this.turn) return;
            const type = target.dataset.type;
            if (!this.hands[owner][type]) return;
            this.selected = { type: 'hand', pieceType: type, owner: owner };
            this.validMoves = this.getLegalDropMoves(type, owner);
            this.render();
        }
        deselect() { this.selected = null; this.validMoves = []; this.render(); }

        performMoveUI(move) {
            if (this.currentStep < this.states.length - 1) {
                this.states = this.states.slice(0, this.currentStep + 1);
                this.history = this.history.slice(0, this.currentStep);
            }
            const nextState = JSON.parse(JSON.stringify(this.currentState));
            let moveText = ""; let promoted = false; let fromStr = "";
            const { r: toR, c: toC } = move;

            if (this.selected.type === 'board') {
                const { r: fromR, c: fromC } = this.selected;
                const piece = nextState.board[fromR][fromC];
                const isPromotable = ["FU","KY","KE","GI","KA","HI"].includes(piece.type) && !piece.promoted;
                const inZone = (this.turn === 'sente' && (toR <= 2 || fromR <= 2)) || (this.turn === 'gote' && (toR >= 6 || fromR >= 6));
                if (isPromotable && inZone) { if (confirm("Êàê„Çä„Åæ„Åô„ÅãÔºü")) promoted = true; }
                const target = nextState.board[toR][toC];
                if (target) {
                    const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                    const rawType = demoteMap[target.type] || target.type;
                    if (!nextState.hands[this.turn][rawType]) nextState.hands[this.turn][rawType] = 0;
                    nextState.hands[this.turn][rawType]++;
                }
                nextState.board[fromR][fromC] = null;
                piece.promoted = piece.promoted || promoted;
                if (promoted) piece.type = this.promoteType(piece.type);
                nextState.board[toR][toC] = piece;
                fromStr = `(${9-fromC}${fromR+1})`;
                moveText = this.generateKifuText(toR, toC, piece.type, promoted, false, fromStr, nextState.lastTo);
            } else {
                const { pieceType } = this.selected;
                nextState.hands[this.turn][pieceType]--;
                nextState.board[toR][toC] = { type: pieceType, owner: this.turn, promoted: false };
                moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
            }
            
            nextState.turn = this.turn === 'sente' ? 'gote' : 'sente';
            nextState.lastTo = { r: toR, c: toC };
            nextState.posHash = this.generateHash(nextState);

            if (this.checkSennichite(nextState)) { moveText += " (ÂçÉÊó•Êâã)"; nextState.isGameOver = true; nextState.msg = "ÂçÉÊó•Êâã\nÂºï„ÅçÂàÜ„Åë"; }
            else if (this.checkMateStatus(nextState)) { moveText += " (Ë©∞„Åø)"; nextState.isGameOver = true; const w = this.turn === 'sente' ? (document.getElementById('meta-sente').value||'ÂÖàÊâã') : (document.getElementById('meta-gote').value||'ÂæåÊâã'); nextState.msg = `${w} Âãù\n(Ë©∞„Åø)`; }

            this.states.push(nextState);
            this.history.push(moveText);
            this.currentStep++;
            this.deselect();
            this.updateView();
        }

        generateHash(state) { return JSON.stringify({b:state.board, h:state.hands, t:state.turn}); }
        checkSennichite(state) {
            const currentHash = state.posHash;
            let count = 0;
            for (const s of this.states) { if (s.posHash === currentHash) count++; }
            return count >= 3; 
        }
        checkMateStatus(state) {
            const turn = state.turn; 
            if (!this.isKingInCheck(state.board, turn)) return false;
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const p = state.board[r][c]; if (p && p.owner === turn) { const moves = this.getBoardMoves(r, c, p, state.board); for (const m of moves) { if (!this.willBeCheckedInternal(state.board, r, c, m.r, m.c, turn, false)) return false; } } } }
            for (const type of Object.keys(state.hands[turn])) { if (state.hands[turn][type] > 0) { const drops = this.getDropMoves(type, turn, state.board); for (const d of drops) { if (!this.willBeCheckedInternal(state.board, null, null, d.r, d.c, turn, true, type)) return false; } } }
            return true;
        }
        isKingInCheck(board, owner) {
            let kR = -1, kC = -1;
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if(p && p.type === 'OU' && p.owner === owner) { kR = r; kC = c; break; } } }
            if (kR === -1) return false;
            const enemy = owner === 'sente' ? 'gote' : 'sente';
            for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = board[r][c]; if (p && p.owner === enemy) { const moves = this.getBoardMoves(r, c, p, board); if (moves.some(m => m.r === kR && m.c === kC)) return true; } } }
            return false;
        }
        getLegalMoves(r, c, piece) { const rawMoves = this.getBoardMoves(r, c, piece, this.board); return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, r, c, move.r, move.c, piece.owner, false)); }
        getLegalDropMoves(type, owner) { const rawMoves = this.getDropMoves(type, owner, this.board); return rawMoves.filter(move => !this.willBeCheckedInternal(this.board, null, null, move.r, move.c, owner, true, type)); }
        willBeCheckedInternal(board, fromR, fromC, toR, toC, owner, isDrop, dropType) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            if (isDrop) { tempBoard[toR][toC] = { type: dropType, owner: owner, promoted: false }; } else { const p = tempBoard[fromR][fromC]; tempBoard[fromR][fromC] = null; tempBoard[toR][toC] = p; }
            return this.isKingInCheck(tempBoard, owner);
        }
        getBoardMoves(r, c, piece, currentBoard) {
            const moves = []; const def = MOVES[piece.type]; const flip = piece.owner === 'sente' ? 1 : -1;
            const isValid = (nr, nc) => nr >= 0 && nr < 9 && nc >= 0 && nc < 9;
            const isFriend = (nr, nc) => currentBoard[nr][nc] && currentBoard[nr][nc].owner === piece.owner;
            if (def.step) { def.step.forEach(([dr, dc]) => { const nr = r + (dr * flip), nc = c + (dc * flip); if (isValid(nr, nc) && !isFriend(nr, nc)) moves.push({ r: nr, c: nc }); }); }
            if (def.slide) { def.slide.forEach(([dr, dc]) => { let currR = r, currC = c; while(true) { currR += (dr * flip); currC += (dc * flip); if (!isValid(currR, currC) || isFriend(currR, currC)) break; moves.push({ r: currR, c: currC }); if (currentBoard[currR][currC]) break; } }); }
            return moves;
        }
        getDropMoves(type, owner, currentBoard) {
            const moves = [];
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (currentBoard[r][c]) continue; if (type === 'FU' && this.isNifu(c, owner, currentBoard)) continue; if (this.isStuck(r, type, owner)) continue; moves.push({ r, c }); } }
            return moves;
        }
        promoteType(t) { const m = { FU:'TO', KY:'NY', KE:'NK', GI:'NG', KA:'UM', HI:'RY' }; return m[t] || t; }
        isNifu(c, o, b) { for (let r = 0; r < 9; r++) { const p = b[r][c]; if (p && p.owner === o && p.type === 'FU' && !p.promoted) return true; } return false; }
        isStuck(r, t, o) { if (o === 'sente') { if ((t === 'FU' || t === 'KY') && r === 0) return true; if (t === 'KE' && r <= 1) return true; } else { if ((t === 'FU' || t === 'KY') && r === 8) return true; if (t === 'KE' && r >= 7) return true; } return false; }

        // --- Controls ---
        prev() { if(this.currentStep > 0) { this.currentStep--; this.updateView(); } }
        next() { if(this.currentStep < this.states.length - 1) { this.currentStep++; this.updateView(); } }
        goto(step) { if (step === -1) step = this.states.length - 1; this.currentStep = Math.max(0, Math.min(step, this.states.length - 1)); this.updateView(); }
        
        undo() {
            if (this.currentStep === 0) return;
            this.states.pop(); this.history.pop(); this.currentStep--;
            const st = this.states[this.currentStep];
            this.isGameOver = st.isGameOver;
            this.updateView();
        }

        resign() { 
            if (this.currentState.isGameOver) return; if (!confirm("Êäï‰∫Ü„Åó„Åæ„Åô„ÅãÔºü")) return; 
            const state = JSON.parse(JSON.stringify(this.currentState)); state.isGameOver = true; 
            state.msg = `${this.turn === 'sente' ? (document.getElementById('meta-sente').value||'‚ñ≤ÂÖàÊâã') : (document.getElementById('meta-gote').value||'‚ñ≥ÂæåÊâã')} Êäï‰∫Ü`; 
            this.states.push(state); this.history.push("Êäï‰∫Ü"); this.currentStep++; this.updateView(); 
        }
        jishogi() { 
            if (this.currentState.isGameOver) return; if (!confirm("ÊåÅÂ∞ÜÊ£ãÔºàÂºï„ÅçÂàÜ„ÅëÔºâ„Å´„Åó„Åæ„Åô„ÅãÔºü")) return; 
            const state = JSON.parse(JSON.stringify(this.currentState)); state.isGameOver = true; state.msg = "ÊåÅÂ∞ÜÊ£ã\nÂºï„ÅçÂàÜ„Åë"; 
            this.states.push(state); this.history.push("ÊåÅÂ∞ÜÊ£ã"); this.currentStep++; this.updateView(); 
        }

        updateView() { 
            this.render(); this.updateHandLabels(); 
            const overlay = document.getElementById('game-over-msg'); 
            if (this.currentState.isGameOver) { overlay.innerText = this.currentState.msg; overlay.classList.add('visible'); } else { overlay.classList.remove('visible'); }
            document.getElementById('turn-indicator').innerText = `ÊâãÁï™: ${this.turn === 'sente' ? '‚ñ≤' : '‚ñ≥'}`;
            document.getElementById('last-move-display').innerText = (this.currentStep > 0) ? `${this.currentStep}: ${this.history[this.currentStep-1]}` : "ÈñãÂßãÂ±ÄÈù¢";
        }
        
        render() {
            const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
            let checkedPos = null;
            if (this.isKingInCheck(this.board, this.turn)) { for(let r=0; r<9; r++){ for(let c=0; c<9; c++){ const p = this.board[r][c]; if(p && p.type === 'OU' && p.owner === this.turn) { checkedPos = {r,c}; break; } } } }
            for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const cell = document.createElement('div'); cell.className = 'cell'; if (this.selected && this.selected.type === 'board' && this.selected.r === r && this.selected.c === c) cell.classList.add('selected'); if (this.validMoves.some(m => m.r === r && m.c === c)) cell.classList.add('valid'); 
            if (checkedPos && checkedPos.r === r && checkedPos.c === c) cell.classList.add('checked');
            cell.onclick = () => this.onCellClick(r, c); const p = this.board[r][c]; if (p) { const span = document.createElement('span'); span.className = `piece ${p.owner} ${p.promoted ? 'promoted' : ''} ${p.owner}`; span.innerText = PIECE_NAMES[p.type]; cell.appendChild(span); } boardEl.appendChild(cell); } }
            this.renderHand('sente'); this.renderHand('gote');
        }
        renderHand(owner) { const container = document.getElementById(`hand-${owner}-container`); container.innerHTML = ''; for (const [type, count] of Object.entries(this.hands[owner])) { if (count > 0) { const div = document.createElement('div'); div.className = 'hand-piece'; div.dataset.type = type; div.innerHTML = `${PIECE_NAMES[type]}<span class="count">${count>1?count:''}</span>`; if (this.selected && this.selected.type === 'hand' && this.selected.owner === owner && this.selected.pieceType === type) div.classList.add('selected'); container.appendChild(div); } } }
        
        generateKifuText(r, c, type, promoted, isDrop, fromStr, lastTo) { const x = 9 - c; const y = NUM_KANJI[r + 1]; const xStr = NUM_ZENKAKU[x]; let dest = `${xStr}${y}`; if (lastTo && lastTo.r === r && lastTo.c === c) dest = "Âêå„ÄÄ"; let pName = PIECE_NAMES[type]; if (promoted) pName = (type === 'FU' ? '„Å®' : (type === 'KA' ? 'È¶¨' : (type === 'HI' ? 'Èæç' : pName + 'Êàê'))); if (promoted && !pName.endsWith('Êàê') && !['„Å®','È¶¨','Èæç'].includes(pName)) pName += 'Êàê'; return `${dest}${pName}${isDrop ? 'Êâì' : ''}${fromStr}`; }
        createKIFString() { 
            const dRaw = document.getElementById('meta-date-text').value;
            const dFmt = this.formatDateForKIF(dRaw);
            let kif = `# KIF formated by WebShogi\n`; kif += `ÈñãÂßãÊó•ÊôÇÔºö${dFmt}\n`; kif += `Ê£ãÊà¶Ôºö${document.getElementById('meta-event').value}\n`; kif += `ÂÖàÊâãÔºö${document.getElementById('meta-sente').value}\n`; kif += `ÂæåÊâãÔºö${document.getElementById('meta-gote').value}\n`; kif += `ÊâãÊï∞----ÊåáÊâã---------Ê∂àË¥πÊôÇÈñì--\n`; this.history.forEach((line, i) => kif += `${String(i + 1).padStart(4, ' ')} ${line}\n`); return kif; 
        }
        downloadKIF() { const blob = new Blob([this.createKIFString()], { type: 'text/plain' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `shogi_${this.formatDateForKIF(document.getElementById('meta-date-text').value).replace(/\//g,'')}.kif`; a.click(); }
        
        // --- Import Logic ---
        handleFileSelect(evt) {
            const file = evt.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const buffer = e.target.result;
                let decoder = new TextDecoder('shift-jis'); let text = decoder.decode(buffer);
                if (!text.includes('ÊâãÊï∞') && !text.includes('ÂÖàÊâã') && !text.includes('1 ')) { decoder = new TextDecoder('utf-8'); text = decoder.decode(buffer); }
                this.parseKIF(text); closeModal();
            };
            reader.readAsArrayBuffer(file);
        }
        loadKIFFromText() {
            const text = document.getElementById('kif-paste-area').value;
            if(!text) return;
            this.parseKIF(text);
            closeModal();
        }

        parseKIF(text) {
            if(!confirm("ÁèæÂú®„ÅÆÁõ§Èù¢„ÇíÁ†¥Ê£Ñ„Åó„Å¶Ë™≠„ÅøËæº„Åø„Åæ„Åô„ÅãÔºü")) return;
            this.init();
            const lines = text.split(/\r\n|\n/);
            const moveRegex = /^\s*[0-9]+\s+([Ôºë-Ôºô1-9Âêå])\s?([‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù1-9„ÄÄ])\s?(.*)/; 
            lines.forEach(line => {
                if(line.includes("Ê£ãÊà¶Ôºö")) document.getElementById('meta-event').value = line.split("Ôºö")[1].trim();
                if(line.includes("ÂÖàÊâãÔºö")) document.getElementById('meta-sente').value = line.split("Ôºö")[1].trim();
                if(line.includes("ÂæåÊâãÔºö")) document.getElementById('meta-gote').value = line.split("Ôºö")[1].trim();
                const dateMatch = line.match(/ÈñãÂßãÊó•ÊôÇ[Ôºö:]\s*(.+)/);
                if (dateMatch) {
                    const dStr = dateMatch[1].trim();
                    const stdDate = dStr.match(/(\d{4})[./-](\d{1,2})[./-](\d{1,2})/);
                    if(stdDate) document.getElementById('meta-date-text').value = `${stdDate[1]}/${String(stdDate[2]).padStart(2,'0')}/${String(stdDate[3]).padStart(2,'0')}`;
                    else document.getElementById('meta-date-text').value = dStr;
                }
            });
            this.updateHandLabels();

            for (let line of lines) {
                const match = line.match(moveRegex);
                if (match) {
                    let toXStr = match[1]; let toYStr = match[2]; let rest = match[3].trim();
                    let toC, toR;
                    if (toXStr === 'Âêå') { const lastTo = this.currentState.lastTo; if (!lastTo) continue; toR = lastTo.r; toC = lastTo.c; } 
                    else { const x = this.toNum(toXStr); const y = this.kanjiToNum(toYStr); toC = 9 - x; toR = y - 1; }
                    const fromMatch = rest.match(/\((\d)(\d)\)/);
                    const isDrop = rest.includes('Êâì');
                    const isPromote = rest.includes('Êàê') && !rest.includes('ÊàêÈäÄ') && !rest.includes('ÊàêÊ°Ç') && !rest.includes('ÊàêÈ¶ô');
                    let pieceType = 'FU';
                    for (const [key, val] of Object.entries(PIECE_NAMES)) { if (rest.startsWith(val)) { pieceType = key; break; } }
                    if (rest.includes('ÊàêÈäÄ')) pieceType = 'GI'; if (rest.includes('„Å®')) pieceType = 'FU'; 

                    const nextState = JSON.parse(JSON.stringify(this.currentState));
                    const turn = nextState.turn;
                    let moveText = "";

                    if (isDrop) {
                         nextState.hands[turn][pieceType]--;
                         nextState.board[toR][toC] = { type: pieceType, owner: turn, promoted: false };
                         moveText = this.generateKifuText(toR, toC, pieceType, false, true, "", nextState.lastTo);
                    } else {
                        let fromR, fromC;
                        if (fromMatch) { const fx = parseInt(fromMatch[1]); const fy = parseInt(fromMatch[2]); fromC = 9 - fx; fromR = fy - 1; } else { continue; }
                        const piece = nextState.board[fromR][fromC];
                        const target = nextState.board[toR][toC];
                        if (target) {
                            const demoteMap = { TO:'FU', NY:'KY', NK:'KE', NG:'GI', UM:'KA', RY:'HI' };
                            const rawType = demoteMap[target.type] || target.type;
                            if (!nextState.hands[turn][rawType]) nextState.hands[turn][rawType] = 0;
                            nextState.hands[turn][rawType]++;
                        }
                        nextState.board[fromR][fromC] = null;
                        piece.promoted = piece.promoted || isPromote;
                        if (isPromote) piece.type = this.promoteType(piece.type);
                        nextState.board[toR][toC] = piece;
                        moveText = line.split('(')[0].trim() + `(${9-fromC}${fromR+1})`;
                    }
                    nextState.turn = turn === 'sente' ? 'gote' : 'sente';
                    nextState.lastTo = { r: toR, c: toC };
                    nextState.posHash = this.generateHash(nextState);

                    if (this.checkSennichite(nextState)) { moveText += " (ÂçÉÊó•Êâã)"; nextState.isGameOver = true; nextState.msg = "ÂçÉÊó•Êâã\nÂºï„ÅçÂàÜ„Åë"; } 
                    else if (this.checkMateStatus(nextState)) { moveText += " (Ë©∞„Åø)"; nextState.isGameOver = true; const w = turn==='sente'?document.getElementById('meta-sente').value:document.getElementById('meta-gote').value; nextState.msg = `${w||(turn==='sente'?'ÂÖàÊâã':'ÂæåÊâã')} Âãù\n(Ë©∞„Åø)`; }
                    else if (line.includes("Êäï‰∫Ü")) { nextState.isGameOver = true; nextState.msg = line.split(/\s+/)[1] + " Êäï‰∫Ü"; }
                    else if (line.includes("ÊåÅÂ∞ÜÊ£ã") || line.includes("ÂçÉÊó•Êâã")) { nextState.isGameOver = true; nextState.msg = "Âºï„ÅçÂàÜ„Åë"; }
                    else if (line.includes("ÂèçÂâá")) { nextState.isGameOver = true; nextState.msg = "ÂèçÂâáÊ±∫ÁùÄ"; }

                    this.states.push(nextState);
                    this.history.push(moveText);
                    this.currentStep++;
                }
            }
            this.updateView();
            alert("Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü");
        }
        toNum(str) { const zen = "ÔºëÔºíÔºìÔºîÔºïÔºñÔºóÔºòÔºô"; const idx = zen.indexOf(str); return idx >= 0 ? idx + 1 : parseInt(str); }
        kanjiToNum(str) { const k = "‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù"; const idx = k.indexOf(str); return idx >= 0 ? idx + 1 : this.toNum(str); }
    }

    const game = new ShogiGame();
</script>
</body>
</html>
